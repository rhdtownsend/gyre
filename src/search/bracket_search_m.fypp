! Module  : bracket_search_m
! Purpose : mode searching (real, bracketing)
!
! Copyright 2013-2025 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module bracket_search_m

   ! Uses

   use forum_m, only: RD

   use ad_bvp_m
   use bvp_m
   use discrim_m
   use ext_m
   use mode_m
   use num_par_m
   use rad_bvp_m
   use root_m
   use state_m
   use status_m
   use util_m
   use wave_m

   use omp_lib

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Module variables

   integer, save :: id_m = 0

   ! Access specifiers

   public :: bracket_search

   ! Default access

   private

contains

   subroutine bracket_search(bp, omega, omega_min, omega_max, nm_p, process_mode)

      class(bvp_rt), intent(inout) :: bp
      real(RD), intent(in)         :: omega(:)
      real(RD), intent(in)         :: omega_min
      real(RD), intent(in)         :: omega_max
      type(num_par_t), intent(in)  :: nm_p
      interface
         subroutine process_mode (md, n_iter, chi)
            use ext_m
            use mode_m
            implicit none (type, external)
            type(mode_t), intent(in)  :: md
            integer, intent(in)       :: n_iter
            type(ext_rt), intent(in)  :: chi
         end subroutine process_mode
      end interface

      type(ext_rt) :: discrim(SIZE(omega))

      ! Search for roots via bracketing and then solving

      ! The code below could be simplified using OMP IF clauses, but
      ! they seem to mess up inner parallel regions (all the code ends
      ! up running on one core)

      if (nm_p%parallel_scan) then

         !$OMP PARALLEL FIRSTPRIVATE(bp)
         call scan_discrim_(bp, omega, discrim)
         call bracket_and_solve_(bp, omega, discrim, omega_min, omega_max, nm_p, process_mode)
         !$OMP END PARALLEL

      else

         call scan_discrim_(bp, omega, discrim)
         call bracket_and_solve_(bp, omega, discrim, omega_min, omega_max, nm_p, process_mode)

      end if

      ! Finish

      return

   end subroutine bracket_search

   !****

   subroutine scan_discrim_(bp, omega, discrim)

      class(bvp_rt), intent(inout) :: bp
      real(RD), intent(in)         :: omega(:)
      type(ext_rt), intent(out)    :: discrim(:)

      integer  :: c_beg
      integer  :: c_end
      integer  :: c_rate
      integer  :: i
      real(RD) :: discrim_f
      integer  :: discrim_e

      @:CHECK_BOUNDS(SIZE(discrim), SIZE(omega))

      ! Evaluate the discriminant at the frequency scan points

      !$OMP MASTER
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 100) 'Evaluating discriminant'
100      format(A)
      endif
      !$OMP END MASTER

      call SYSTEM_CLOCK(c_beg, c_rate)

      !$OMP DO PRIVATE(discrim_f, discrim_e)
      discrim_loop: do i = 1, SIZE(omega)

         call eval_discrim(bp, state_rt(omega(i)), discrim(i))

         discrim_f = FRACTION(discrim(i))
         discrim_e = EXPONENT(discrim(i))

         if (check_log_level('DEBUG')) then
            write(OUTPUT_UNIT, 110) omega(i), discrim_f, discrim_e
110         format(2X,E24.16,2X,F19.16,2X,I7)
         endif

      end do discrim_loop
      !$OMP END DO

      call SYSTEM_CLOCK(c_end)

      !$OMP MASTER
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 120) 'Time elapsed :', REAL(c_end-c_beg, RD)/c_rate, 's'
120      format(2X,A,F10.3,1X,A/)
      endif
      !$OMP END MASTER

      ! Finish

      return

   end subroutine scan_discrim_

   !****

   subroutine bracket_and_solve_(bp, omega, discrim, omega_min, omega_max, nm_p, process_mode)

      class(bvp_rt), intent(inout) :: bp
      real(RD), intent(in)         :: omega(:)
      type(ext_rt), intent(in)     :: discrim(:)
      real(RD), intent(in)         :: omega_min
      real(RD), intent(in)         :: omega_max
      type(num_par_t), intent(in)  :: nm_p
      interface
         subroutine process_mode (md, n_iter, chi)
            use ext_m
            use mode_m
            implicit none (type, external)
            type(mode_t), intent(in)  :: md
            integer, intent(in)       :: n_iter
            type(ext_rt), intent(in)  :: chi
         end subroutine process_mode
      end interface

      integer      :: c_beg
      integer      :: c_end
      integer      :: c_rate
      integer      :: i
      integer      :: n_iter
      type(ext_rt) :: omega_root
      integer      :: stat
      type(wave_t) :: wv
      type(mode_t) :: md
      type(ext_rt) :: chi

      @:CHECK_BOUNDS(SIZE(discrim), SIZE(omega))

      ! Look for brackets and process them

      !$OMP MASTER
      if (check_log_level('INFO')) then

         write(OUTPUT_UNIT, 100) 'Root Solving'
100      format(A)

         write(OUTPUT_UNIT, 110) 'l', 'm', 'n_pg', 'n_p', 'n_g', 'Re(omega)', 'Im(omega)', 'chi', 'n_iter'
110      format(1X,A3,1X,A4,1X,A7,1X,A6,1X,A6,1X,A15,1X,A15,1X,A10,1X,A6)

      endif
      !$OMP END MASTER

      call SYSTEM_CLOCK(c_beg, c_rate)

      !$OMP DO PRIVATE(n_iter, omega_root, stat, wv, md, chi) SCHEDULE(GUIDED)
      mode_loop : do i = 1, SIZE(omega)-1

         ! Check for a bracket

         if (discrim(i)*discrim(i+1) > ext_rt(0._RD)) cycle mode_loop

         ! Find the discriminant root

         n_iter = 0

         call solve_root(eval_discrim_, ext_rt(omega(i)), ext_rt(omega(i+1)), &
            ext_rt(0._RD), nm_p, omega_root, stat, n_iter=n_iter, &
            n_iter_max=nm_p%n_iter_max, f_x_a=discrim(i), f_x_b=discrim(i+1))
         if (stat /= STAT_OK) then
            call report_stat_(stat, 'solve')
         endif

         ! Construct the mode_t

         !$OMP ATOMIC
         id_m = id_m + 1

         select type (bp)
         type is (ad_bvp_t)
            wv = wave_t(bp, state_rt(CMPLX(real(omega_root), KIND=RD)), id_m)
         type is (rad_bvp_t)
            wv = wave_t(bp, state_rt(CMPLX(real(omega_root), KIND=RD)), id_m)
         class default
            @:ABORT('invalid bp class')
         end select

         md = mode_t(wv)

         chi = abs(md%discrim)/max(abs(discrim(i)), abs(discrim(i+1)))

         ! Process it

         !$OMP CRITICAL
         call process_mode(md, n_iter, chi)
         !$OMP END CRITICAL

      end do mode_loop
      !$OMP END DO

      call SYSTEM_CLOCK(c_end)

      !$OMP MASTER
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 130) 'Time elapsed :', REAL(c_end-c_beg, RD)/c_rate, 's'
130      format(2X,A,1X,F10.3,1X,A/)
      endif
      !$OMP END MASTER

      ! Finish

      return

   contains

      subroutine eval_discrim_(x, discrim, stat)

         type(ext_rt), intent(in)  :: x
         type(ext_rt), intent(out) :: discrim
         integer, intent(out)      :: stat

         real(RD) :: omega

         ! Evaluate the frequency from x

         omega = real(x)

         ! Evaluate the discriminant

         if (omega >= omega_min .AND. omega <= omega_max) then

            call eval_discrim(bp, state_rt(omega), discrim)

            stat = STAT_OK

         else

            stat = STAT_OMEGA_DOMAIN

         end if

         ! Finish

         return

      end subroutine eval_discrim_

      subroutine report_stat_(stat, stage_str)

         integer, intent(in)      :: stat
         character(*), intent(in) :: stage_str

         ! Report the status

         if (check_log_level('WARN')) then

            write(OUTPUT_UNIT, 100) 'Failed during ', stage_str, ' : ', stat_str(stat)
100         format(4A)

         endif

         if (check_log_level('INFO')) then

            write(OUTPUT_UNIT, 110) 'n_iter  :', n_iter
110         format(3X,A,1X,I0)

            write(OUTPUT_UNIT, 120) 'omega_a :', omega(i)
            write(OUTPUT_UNIT, 120) 'omega_b :', omega(i+1)
120         format(3X,A,1X,E24.16)

         end if

         ! Finish

         return

      end subroutine report_stat_

   end subroutine bracket_and_solve_

end module bracket_search_m
