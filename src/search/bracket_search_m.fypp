! Module  : bracket_search_m
! Purpose : mode searching (real, bracketing)
!
! Copyright 2013-2025 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module bracket_search_m

   ! Uses

   use forum_m, only: RD

   use ad_bvp_m
   use bvp_m
   use discrim_m
   use ext_m
   use mode_m
   use num_par_m
   use rad_bvp_m
   use root_m
   use state_m
   use status_m
   use util_m
   use wave_m

   use omp_lib

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Derived-type definitions

   type :: bracket_t
      real(RD) :: omega
      real(RD) :: chi
      integer  :: n_iter
      integer  :: id
      logical  :: active
   end type bracket_t

   ! Module variables

   integer, save :: id_m = 0

   ! Access specifiers

   public :: bracket_search

   ! Default access

   private

contains

   subroutine bracket_search(bp, omega, omega_min, omega_max, nm_p, process_mode)

      class(bvp_rt), intent(inout) :: bp
      real(RD), intent(in)         :: omega(:)
      real(RD), intent(in)         :: omega_min
      real(RD), intent(in)         :: omega_max
      type(num_par_t), intent(in)  :: nm_p
      interface
         subroutine process_mode(md)
            use mode_m
            implicit none (type, external)
            type(mode_t), intent(in) :: md
         end subroutine process_mode
      end interface

      type(ext_rt)    :: discrim(SIZE(omega))
      type(bracket_t) :: bk(SIZE(omega)-1)

      ! Search for roots via bracketing and then solving

      ! The code below could be simplified using OMP IF clauses, but
      ! they seem to mess up inner parallel regions (all the code ends
      ! up running on one core)

      if (nm_p%parallel_scan) then

         !$OMP PARALLEL FIRSTPRIVATE(bp)
         call scan_discrim_(bp, omega, discrim)
         call create_brackets_(bp, omega, discrim, omega_min, omega_max, nm_p, bk)
         call process_brackets_(bp, bk, process_mode)
         !$OMP END PARALLEL

      else

         call scan_discrim_(bp, omega, discrim)
         call create_brackets_(bp, omega, discrim, omega_min, omega_max, nm_p, bk)
         call process_brackets_(bp, bk, process_mode)

      end if

      ! Finish

      return

   end subroutine bracket_search

   !****

   subroutine scan_discrim_(bp, omega, discrim)

      class(bvp_rt), intent(inout) :: bp
      real(RD), intent(in)         :: omega(:)
      type(ext_rt), intent(out)    :: discrim(:)

      integer  :: c_beg
      integer  :: c_end
      integer  :: c_rate
      integer  :: i
      real(RD) :: discrim_f
      integer  :: discrim_e

      @:CHECK_BOUNDS(SIZE(discrim), SIZE(omega))

      ! Evaluate the discriminant at the frequency scan points

      !$OMP MASTER
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 100) 'Discriminant evaluation'
100      format(A)
      endif
      !$OMP END MASTER

      call SYSTEM_CLOCK(c_beg, c_rate)

      !$OMP DO PRIVATE(discrim_f, discrim_e)
      omega_loop: do i = 1, SIZE(omega)

         call eval_discrim(bp, state_rt(omega(i)), discrim(i))

         discrim_f = FRACTION(discrim(i))
         discrim_e = EXPONENT(discrim(i))

         if (check_log_level('DEBUG')) then
            write(OUTPUT_UNIT, 110) omega(i), discrim_f, discrim_e
110         format(2X,E24.16,2X,F19.16,2X,I7)
         endif

      end do omega_loop
      !$OMP END DO

      call SYSTEM_CLOCK(c_end)

      !$OMP MASTER
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 120) 'Time elapsed :', REAL(c_end-c_beg, RD)/c_rate, 's'
120      format(2X,A,F10.3,1X,A/)
      endif
      !$OMP END MASTER

      ! Finish

      return

   end subroutine scan_discrim_

   !****

   subroutine create_brackets_(bp, omega, discrim, omega_min, omega_max, nm_p, bk)

      class(bvp_rt), intent(inout)           :: bp
      real(RD), intent(in)                   :: omega(:)
      type(ext_rt), intent(in)               :: discrim(:)
      real(RD), intent(in)                   :: omega_min
      real(RD), intent(in)                   :: omega_max
      type(num_par_t), intent(in)            :: nm_p
      type(bracket_t), intent(out)           :: bk(:)

      integer      :: c_beg
      integer      :: c_end
      integer      :: c_rate
      integer      :: i
      type(ext_rt) :: x_root
      type(ext_rt) :: f_x_root
      integer      :: stat

      @:CHECK_BOUNDS(SIZE(discrim), SIZE(omega))
      @:CHECK_BOUNDS(SIZE(bk), SIZE(omega)-1)

      ! Find discriminant brackets, and solve for the bracketed
      ! root

      !$OMP MASTER
      if (check_log_level('INFO')) then

         write(OUTPUT_UNIT, 100) 'Root Solving'
100      format(A)

      endif
      !$OMP END MASTER

      call SYSTEM_CLOCK(c_beg, c_rate)

      !$OMP DO PRIVATE(x_root, stat, f_x_root) SCHEDULE(GUIDED)
      omega_loop : do i = 1, SIZE(omega)-1

         ! Check for a bracket

         bk(i)%active = discrim(i)*discrim(i+1) <= ext_rt(0._RD)

         if (.NOT. bk(i)%active) cycle omega_loop

         ! Find the discriminant root

         bk(i)%n_iter = 0

         call solve_root(eval_discrim_, ext_rt(omega(i)), ext_rt(omega(i+1)), &
            ext_rt(0._RD), nm_p, x_root, stat, n_iter=bk(i)%n_iter, &
            n_iter_max=nm_p%n_iter_max, f_x_a=discrim(i), f_x_b=discrim(i+1), f_x_root=f_x_root)
         if (stat /= STAT_OK) then
            call report_stat_(stat, 'solve')
            bk(i)%active = .FALSE.
            cycle omega_loop
         endif

         bk(i)%omega = real(x_root)
         bk(i)%chi = real(abs(f_x_root)/max(abs(discrim(i)), abs(discrim(i+1))))

      end do omega_loop
      !$OMP END DO

      call SYSTEM_CLOCK(c_end)

      !$OMP MASTER
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 130) 'Time elapsed :', REAL(c_end-c_beg, RD)/c_rate, 's'
130      format(2X,A,1X,F10.3,1X,A/)
      endif
      !$OMP END MASTER

      ! Finish

   contains

      subroutine eval_discrim_(x, discrim, stat)

         type(ext_rt), intent(in)  :: x
         type(ext_rt), intent(out) :: discrim
         integer, intent(out)      :: stat

         real(RD) :: omega

         ! Evaluate the frequency from x

         omega = real(x)

         ! Evaluate the discriminant

         if (omega >= omega_min .AND. omega <= omega_max) then

            call eval_discrim(bp, state_rt(omega), discrim)

            stat = STAT_OK

         else

            stat = STAT_OMEGA_DOMAIN

         end if

         ! Finish

         return

      end subroutine eval_discrim_

      subroutine report_stat_(stat, stage_str)

         integer, intent(in)      :: stat
         character(*), intent(in) :: stage_str

         ! Report the status

         if (check_log_level('WARN')) then

            write(OUTPUT_UNIT, 100) 'Failed during ', stage_str, ' : ', stat_str(stat)
100         format(4A)

         endif

         if (check_log_level('INFO')) then

            write(OUTPUT_UNIT, 110) 'n_iter  :', bk(i)%n_iter
110         format(3X,A,1X,I0)

            write(OUTPUT_UNIT, 120) 'omega_a :', omega(i)
            write(OUTPUT_UNIT, 120) 'omega_b :', omega(i+1)
120         format(3X,A,1X,E24.16)

         end if

         ! Finish

         return

      end subroutine report_stat_

   end subroutine create_brackets_

   !****

   subroutine process_brackets_(bp, bk, process_mode)

      class(bvp_rt), intent(inout)   :: bp
      type(bracket_t), intent(inout) :: bk(:)
      interface
         subroutine process_mode(md)
            use mode_m
            implicit none (type, external)
            type(mode_t), intent(in) :: md
         end subroutine process_mode
      end interface

      integer      :: c_beg
      integer      :: c_end
      integer      :: c_rate
      integer      :: i
      type(wave_t) :: wv
      type(mode_t) :: md
      
      ! Process active brackets

      !$OMP MASTER
      if (check_log_level('INFO')) then

         write(OUTPUT_UNIT, 100) 'Mode Processing'
100      format(A)

         write(OUTPUT_UNIT, 110) 'l', 'm', 'n_pg', 'n_p', 'n_g', 'Re(omega)', 'Im(omega)', 'chi', 'n_iter'
110      format(1X,A3,1X,A4,1X,A7,1X,A6,1X,A6,1X,A15,1X,A15,1X,A10,1X,A6)
      end if
      !$OMP END MASTER

      call SYSTEM_CLOCK(c_beg, c_rate)

      ! Set up ids

      !$OMP MASTER
      do i = 1, SIZE(bk)
         if (bk(i)%active) then
            id_m = id_m + 1
            bk(i)%id = id_m
         end if
      end do
      !$OMP END MASTER

      !$OMP DO PRIVATE(wv, md) SCHEDULE(guided)
      bracket_loop: do i = 1, SIZE(bk)

         if (bk(i)%active) then
      
            ! Construct the mode_t

            select type (bp)
            type is (ad_bvp_t)
               wv = wave_t(bp, state_rt(CMPLX(bk(i)%omega, KIND=RD)), bk(i)%id, bk(i)%chi, bk(i)%n_iter)
            type is (rad_bvp_t)
               wv = wave_t(bp, state_rt(CMPLX(bk(i)%omega, KIND=RD)), bk(i)%id, bk(i)%chi, bk(i)%n_iter)
            class default
               @:ABORT('invalid bp class')
            end select

            md = mode_t(wv)

            ! Process it

            !$OMP CRITICAL
            call process_mode(md)
            !$OMP END CRITICAL

         end if

      end do bracket_loop
      !$OMP END DO

      call SYSTEM_CLOCK(c_end)

      !$OMP MASTER
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 130) 'Time elapsed :', REAL(c_end-c_beg, RD)/c_rate, 's'
130      format(2X,A,1X,F10.3,1X,A/)
      endif
      !$OMP END MASTER

      ! Finish

      return

   end subroutine process_brackets_

end module bracket_search_m
