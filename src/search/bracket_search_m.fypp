! Module  : bracket_search_m
! Purpose : mode searching (real, bracketing)
!
! Copyright 2013-2025 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module bracket_search_m

   ! Uses

   use forum_m, only: RD, sort_indices

   use ad_bvp_m
   use bvp_m
   use discrim_m
   use ext_m
   use mode_m
   use num_par_m
   use rad_bvp_m
   use root_m
   use state_m
   use status_m
   use util_m
   use wave_m

   use omp_lib

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Derived-type definitions

   type :: bracket_t
      real(RD)     :: omega_a
      real(RD)     :: omega_b
      type(ext_rt) :: discrim_a
      type(ext_rt) :: discrim_b
      type(mode_t) :: md
      logical      :: active
   end type bracket_t

   ! Module variables

   integer, save :: id_m = 0

   ! Access specifiers

   public :: bracket_search

   ! Default access

   private

contains

   subroutine bracket_search(bp, omega, omega_min, omega_max, nm_p, process_mode)

      class(bvp_rt), intent(inout) :: bp
      real(RD), intent(in)         :: omega(:)
      real(RD), intent(in)         :: omega_min
      real(RD), intent(in)         :: omega_max
      type(num_par_t), intent(in)  :: nm_p
      interface
         subroutine process_mode(md, culled)
            use mode_m
            implicit none (type, external)
            type(mode_t), intent(in) :: md
            logical, intent(out)     :: culled
         end subroutine process_mode
      end interface
 
      type(ext_rt)    :: discrim(SIZE(omega))
      type(bracket_t) :: br(SIZE(omega)-1)

      ! Search for roots via bracketing, and then solve for modes

      ! The code below could be simplified using OMP IF clauses, but
      ! they seem to mess up inner parallel regions (all the code ends
      ! up running on one core)

      if (nm_p%parallel_scan) then

         !$OMP PARALLEL FIRSTPRIVATE(bp)
         call scan_omega_(bp, omega, discrim)
         call setup_bracket_(omega, discrim, br)
         call find_modes_(bp, omega_min, omega_max, nm_p, br)
         !$OMP END PARALLEL

      else

         call scan_omega_(bp, omega, discrim)
         call setup_bracket_(omega, discrim, br)
         call find_modes_(bp, omega_min, omega_max, nm_p, br)

      end if

      call process_modes_(bp, br, process_mode)

      ! Finish

      return

   end subroutine bracket_search

   !****

   subroutine scan_omega_(bp, omega, discrim)

      class(bvp_rt), intent(inout) :: bp
      real(RD), intent(in)         :: omega(:)
      type(ext_rt), intent(inout)  :: discrim(:)

      integer  :: c_beg
      integer  :: c_end
      integer  :: c_rate
      integer  :: i
      real(RD) :: discrim_f
      integer  :: discrim_e

      @:CHECK_BOUNDS(SIZE(discrim), SIZE(omega))

      ! Evaluate the discriminant at the frequency scan points

      !$OMP SINGLE
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 100) 'Scanning frequencies'
100      format(A)
      endif
      !$OMP END SINGLE

      call SYSTEM_CLOCK(c_beg, c_rate)

      !$OMP DO PRIVATE(discrim_f, discrim_e)
      omega_loop: do i = 1, SIZE(omega)

         call eval_discrim(bp, state_rt(omega(i)), discrim(i))

         if (check_log_level('DEBUG')) then

            discrim_f = FRACTION(discrim(i))
            discrim_e = EXPONENT(discrim(i))

            write(OUTPUT_UNIT, 110) omega(i), discrim_f, discrim_e
110         format(2X,E24.16,2X,F19.16,2X,I7)

         endif

      end do omega_loop
      !$OMP END DO

      call SYSTEM_CLOCK(c_end)

      !$OMP SINGLE
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 120) 'Time elapsed :', REAL(c_end-c_beg, RD)/c_rate, 's'
120      format(2X,A,F10.3,1X,A/)
      endif
      !$OMP END SINGLE

      ! Finish

      return

   end subroutine scan_omega_

   !****

   subroutine setup_bracket_(omega, discrim, br)

      real(RD), intent(in)           :: omega(:)
      type(ext_rt), intent(in)       :: discrim(:)
      type(bracket_t), intent(inout) :: br(:)

      integer :: i

      @:CHECK_BOUNDS(SIZE(discrim), SIZE(omega))
      @:CHECK_BOUNDS(SIZE(br), SIZE(omega)-1)

      ! Set up the bracket array

      !$OMP DO
      bracket_loop : do i = 1, SIZE(br)

         br(i)%omega_a = omega(i)
         br(i)%omega_b = omega(i+1)

         br(i)%discrim_a = discrim(i)
         br(i)%discrim_b = discrim(i+1)

         br(i)%active = discrim(i)*discrim(i+1) <= ext_rt(0._RD)

      end do bracket_loop
      !$OMP END DO

      ! Finish

      return

   end subroutine setup_bracket_

   !****

   subroutine find_modes_(bp, omega_min, omega_max, nm_p, br)

      class(bvp_rt), intent(inout)   :: bp
      real(RD), intent(in)           :: omega_min
      real(RD), intent(in)           :: omega_max
      type(num_par_t), intent(in)    :: nm_p
      type(bracket_t), intent(inout) :: br(:)

      integer      :: c_beg
      integer      :: c_end
      integer      :: c_rate
      integer      :: i
      type(ext_rt) :: x_a
      type(ext_rt) :: x_b
      type(ext_rt) :: f_x_a
      type(ext_rt) :: f_x_b
      type(ext_rt) :: x_root
      type(ext_rt) :: f_x_root
      integer      :: stat
      integer      :: n_iter
      real(RD)     :: omega_root
      real(RD)     :: chi
      type(wave_t) :: wv

      ! Find modes within discriminant brackets

      !$OMP SINGLE
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 100) 'Finding modes'
100      format(A)
      endif
      !$OMP END SINGLE

      call SYSTEM_CLOCK(c_beg, c_rate)

      !$OMP DO PRIVATE(x_a, x_b, f_x_a, f_x_b, x_root, f_x_root, stat, n_iter, omega_root, chi, wv) SCHEDULE(GUIDED)
      bracket_loop : do i = 1, SIZE(br)

         if (.NOT. br(i)%active) cycle bracket_loop

         ! Solve for the root

         x_a = ext_rt(br(i)%omega_a)
         x_b = ext_rt(br(i)%omega_b)
         f_x_a = br(i)%discrim_a
         f_x_b = br(i)%discrim_b

         call solve_root(eval_discrim_, x_a, x_b, ext_rt(0._RD), nm_p, &
            x_root, stat, n_iter=n_iter, n_iter_max=nm_p%n_iter_max, &
            f_x_a=f_x_a, f_x_b=f_x_b, f_x_root=f_x_root)
         if (stat /= STAT_OK) then
            call report_stat_(stat, 'solve')
            br(i)%active = .FALSE.
            cycle bracket_loop
         endif

         omega_root = real(x_root)
         chi = real(abs(f_x_root)/max(abs(f_x_a), abs(f_x_b)))

         ! Construct the mode. Note that a dummy id is used; it will be updated later

         select type (bp)
         type is (ad_bvp_t)
            wv = wave_t(bp, state_rt(omega_root), 0, chi, n_iter)
         type is (rad_bvp_t)
            wv = wave_t(bp, state_rt(omega_root), 0, chi, n_iter)
         class default
            @:ABORT('invalid bp class')
         end select

         br(i)%md = mode_t(wv)

      end do bracket_loop
      !$OMP END DO

      call SYSTEM_CLOCK(c_end)

      !$OMP SINGLE
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 130) 'Time elapsed :', REAL(c_end-c_beg, RD)/c_rate, 's'
130      format(2X,A,1X,F10.3,1X,A/)
      endif
      !$OMP END SINGLE

      ! Finish

   contains

      subroutine eval_discrim_(x, discrim, stat)

         type(ext_rt), intent(in)  :: x
         type(ext_rt), intent(out) :: discrim
         integer, intent(out)      :: stat

         real(RD) :: omega

         ! Evaluate the frequency from x

         omega = real(x)

         ! Evaluate the discriminant

         if (omega >= omega_min .AND. omega <= omega_max) then

            call eval_discrim(bp, state_rt(omega), discrim)

            stat = STAT_OK

         else

            stat = STAT_OMEGA_DOMAIN

         end if

         ! Finish

         return

      end subroutine eval_discrim_

      subroutine report_stat_(stat, stage_str)

         integer, intent(in)      :: stat
         character(*), intent(in) :: stage_str

         ! Report the status

         if (check_log_level('WARN')) then

            write(OUTPUT_UNIT, 100) 'Failed during ', stage_str, ' : ', stat_str(stat)
100         format(4A)

         endif

         if (check_log_level('INFO')) then

            write(OUTPUT_UNIT, 110) 'n_iter  :', n_iter
110         format(3X,A,1X,I0)

            write(OUTPUT_UNIT, 120) 'omega_a :', br(i)%omega_a
            write(OUTPUT_UNIT, 120) 'omega_b :', br(i)%omega_b
120         format(3X,A,1X,E24.16)

         end if

         ! Finish

         return

      end subroutine report_stat_

   end subroutine find_modes_

   !****

   subroutine process_modes_(bp, br, process_mode)

      class(bvp_rt), intent(inout)   :: bp
      type(bracket_t), intent(inout) :: br(:)
      interface
         subroutine process_mode(md, culled)
            use mode_m
            implicit none (type, external)
            type(mode_t), intent(in) :: md
            logical, intent(out)     :: culled
         end subroutine process_mode
      end interface

      integer              :: c_beg
      integer              :: c_end
      integer              :: c_rate
      integer              :: i
      integer, allocatable :: j(:)
      logical              :: culled

      ! Process active brackets

      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 100) 'Processing modes'
100      format(A)
         write(OUTPUT_UNIT, 110) 'id', 'l', 'm', 'n_pg', 'n_p', 'n_g', 'Re(omega)', 'Im(omega)', 'chi', 'n_iter'
110      format(1X,A3,1X,A3,1X,A4,1X,A7,1X,A6,1X,A6,1X,A15,1X,A15,1X,A10,1X,A6)
      end if

      call SYSTEM_CLOCK(c_beg, c_rate)

      ! Set mode ids

      do i = 1, SIZE(br)
         if (br(i)%active) then
            id_m = id_m + 1
            br(i)%md%id = id_m
         else
            br(i)%md%id = HUGE(0)
         end if
      end do

      ! Process the modes, in id-order

      j = sort_indices(br%md%id)

      process_loop: do i = 1, COUNT(br%active)

         associate(md => br(j(i))%md)

            call process_mode(md, culled)

            if (check_log_level('INFO') .AND. .NOT. culled) then
               write(OUTPUT_UNIT, 120) md%id, md%l, md%m, md%n_pg, md%n_p, md%n_g, &
                  md%omega, md%chi, md%n_iter
120            format(1X,I3,1X,I3,1X,I4,1X,I7,1X,I6,1X,I6,1X,E15.8,1X,E15.8,1X,E10.4,1X,I6)
            endif

         end associate

      end do process_loop

      call SYSTEM_CLOCK(c_end)

      write(OUTPUT_UNIT, 130) 'Time elapsed :', REAL(c_end-c_beg, RD)/c_rate, 's'
130   format(2X,A,1X,F10.3,1X,A/)

      ! Finish

      return

   end subroutine process_modes_

end module bracket_search_m
