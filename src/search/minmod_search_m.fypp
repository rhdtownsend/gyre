! Module  : minmod_search_m
! Purpose : mode searching (complex, minmod)
!
! Copyright 2013-2025 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module minmod_search_m

   ! Uses

   use forum_m, only: RD

   use bvp_m
   use discrim_m
   use ext_m
   use num_par_m
   use minim_m
   use prox_search_m
   use state_m
   use status_m
   use util_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Derived-type definitions

   type :: bracket_t
      real(RD)     :: omega_a
      real(RD)     :: omega_b
      real(RD)     :: omega_c
      real(RD)     :: omega_minim
      type(ext_rt) :: mod_discrim_a
      type(ext_rt) :: mod_discrim_b
      type(ext_rt) :: mod_discrim_c
      integer      :: id
      logical      :: active
   end type bracket_t

   ! Module variables

   integer, save :: id_m = 0

   ! Access specifiers

   public :: minmod_search

   ! Default access

   private

contains

   subroutine minmod_search(bp, omega, omega_min, omega_max, nm_p, process_mode)

      class(bvp_ct), intent(inout) :: bp
      real(RD), intent(in)         :: omega(:)
      real(RD), intent(in)         :: omega_min
      real(RD), intent(in)         :: omega_max
      type(num_par_t), intent(in)  :: nm_p
      interface
         subroutine process_mode(md, culled)
            use mode_m
            implicit none (type, external)
            type(mode_t), intent(in) :: md
            logical, intent(out)     :: culled
         end subroutine process_mode
      end interface

      type(ext_rt)    :: mod_discrim(SIZE(omega))
      type(bracket_t) :: br(SIZE(omega)-2)

      ! Search for roots via minimum-modulus bracketing, and then
      ! solve for modes

      ! The code below could be simplified using OMP IF clauses, but
      ! they seem to mess up inner parallel regions (all the code ends
      ! up running on one core)

      if (nm_p%parallel_scan) then

         !$OMP PARALLEL FIRSTPRIVATE(bp)
         call scan_omega_(bp, omega, mod_discrim)
         call setup_brackets_(omega, mod_discrim, br)
         call find_minima_(bp, omega_min, omega_max, nm_p, br)
         !$OMP END PARALLEL

      else

         call scan_omega_(bp, omega, mod_discrim)
         call setup_brackets_(omega, mod_discrim, br)
         call find_minima_(bp, omega_min, omega_max, nm_p, br)

      end if

      ! Search for modes

      call prox_search(bp, CMPLX(PACK(br%omega_minim, MASK=br%active), KIND=RD), PACK(br%id, MASK=br%active), &
         omega_min, omega_max, nm_p, process_mode)

      ! Finish

      return

   end subroutine minmod_search

   !****

   subroutine scan_omega_(bp, omega, mod_discrim)

      class(bvp_ct), intent(inout) :: bp
      real(RD), intent(in)         :: omega(:)
      type(ext_rt), intent(inout)  :: mod_discrim(:)

      integer      :: c_beg
      integer      :: c_end
      integer      :: c_rate
      integer      :: i
      type(ext_ct) :: discrim
      real(RD)     :: mod_discrim_f
      integer      :: mod_discrim_e

      @:CHECK_BOUNDS(SIZE(mod_discrim), SIZE(omega))

      ! Evaluate the discriminant at the frequency scan points

      !$OMP SINGLE
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 100) 'Scanning frequencies'
100      format(A)
      endif
      !$OMP END SINGLE

      call SYSTEM_CLOCK(c_beg, c_rate)

      !$OMP DO PRIVATE(discrim, mod_discrim_f, mod_discrim_e)
      omega_loop: do i = 1, SIZE(omega)

         call eval_discrim(bp, state_ct(omega(i)), discrim)

         mod_discrim(i) = abs(discrim)

         if (check_log_level('DEBUG')) then

            mod_discrim_f = FRACTION(mod_discrim(i))
            mod_discrim_e = EXPONENT(mod_discrim(i))

            write(OUTPUT_UNIT, 110) omega(i), mod_discrim_f, mod_discrim_e
110         format(2X,E24.16,2X,F19.16,2X,I7)

         endif

      end do omega_loop
      !$OMP END DO

      call SYSTEM_CLOCK(c_end)

      !$OMP SINGLE
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 120) 'Time elapsed :', REAL(c_end-c_beg, RD)/c_rate, 's'
120      format(2X,A,F10.3,1X,A/)
      endif
      !$OMP END SINGLE

      ! Finish

      return

   end subroutine scan_omega_

   !****

   subroutine setup_brackets_(omega, mod_discrim, br)

      real(RD), intent(in)           :: omega(:)
      type(ext_rt), intent(in)       :: mod_discrim(:)
      type(bracket_t), intent(inout) :: br(:)

      integer :: i

      @:CHECK_BOUNDS(SIZE(mod_discrim), SIZE(omega))
      @:CHECK_BOUNDS(SIZE(br), SIZE(omega)-2)

      ! Set up the bracket array

      !$OMP DO ORDERED SCHEDULE(STATIC, 1)
      bracket_loop : do i = 1, SIZE(br)

         br(i)%omega_a = omega(i)
         br(i)%omega_b = omega(i+1)
         br(i)%omega_c = omega(i+2)

         br(i)%mod_discrim_a = mod_discrim(i)
         br(i)%mod_discrim_b = mod_discrim(i+1)
         br(i)%mod_discrim_c = mod_discrim(i+2)

         br(i)%active = mod_discrim(i) > mod_discrim(i+1) .AND. mod_discrim(i+2) > mod_discrim(i+1)

         !$OMP ORDERED
         if (br(i)%active) then
            id_m = id_m + 1
            br(i)%id = id_m
         end if
         !$OMP END ORDERED

      end do bracket_loop
      !$OMP END DO

      ! Finish

      return

   end subroutine setup_brackets_

   !****

   subroutine find_minima_(bp, omega_min, omega_max, nm_p, br)

      class(bvp_ct), intent(inout)   :: bp
      real(RD), intent(in)           :: omega_min
      real(RD), intent(in)           :: omega_max
      type(num_par_t), intent(in)    :: nm_p
      type(bracket_t), intent(inout) :: br(:)

      integer      :: c_beg
      integer      :: c_end
      integer      :: c_rate
      integer      :: i
      type(ext_rt) :: x_a
      type(ext_rt) :: x_b
      type(ext_rt) :: x_c
      type(ext_rt) :: f_x_a
      type(ext_rt) :: f_x_b
      type(ext_rt) :: f_x_c
      type(ext_rt) :: x_minim
      integer      :: stat
      integer      :: n_iter

      ! Find discriminant minima within brackets

      !$OMP SINGLE
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 100) 'Finding minima'
100      format(A)
      endif
      !$OMP END SINGLE

      call SYSTEM_CLOCK(c_beg, c_rate)

      !$OMP DO PRIVATE(x_a, x_b, x_c, f_x_a, f_x_b, f_x_c, x_minim, stat, n_iter)
      bracket_loop : do i = 1, SIZE(br)

         if (.NOT. br(i)%active) cycle bracket_loop

         ! Solve for the minimum

         x_a = ext_rt(br(i)%omega_a)
         x_b = ext_rt(br(i)%omega_b)
         x_c = ext_rt(br(i)%omega_c)
         f_x_a = br(i)%mod_discrim_a
         f_x_b = br(i)%mod_discrim_b
         f_x_c = br(i)%mod_discrim_c

         call solve_minim(eval_mod_discrim_, x_a, x_b, x_c, ext_rt(0._RD), nm_p, &
            x_minim, stat, n_iter=n_iter, n_iter_max=nm_p%n_iter_max, &
            f_x_a=f_x_a, f_x_b=f_x_b, f_x_c=f_x_c)

         if (stat /= STAT_OK) then
            call report_stat_(stat, 'solve_minim', n_iter, br(i)%omega_a, br(i)%omega_b, br(i)%omega_c)
            br(i)%active = .FALSE.
            cycle bracket_loop
         endif

         br(i)%omega_minim = real(x_minim)

      end do bracket_loop
      !$OMP END DO

      call SYSTEM_CLOCK(c_end)

      !$OMP SINGLE
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 130) 'Time elapsed :', REAL(c_end-c_beg, RD)/c_rate, 's'
130      format(2X,A,1X,F10.3,1X,A/)
      endif
      !$OMP END SINGLE

      ! Finish

   contains

      subroutine eval_mod_discrim_(x, mod_discrim, stat)

         type(ext_rt), intent(in)  :: x
         type(ext_rt), intent(out) :: mod_discrim
         integer, intent(out)      :: stat

         real(RD)     :: omega
         type(ext_ct) :: discrim

         ! Evaluate the frequency from x

         omega = real(x)

         ! Evaluate the modulus of the discriminant

         if (omega >= omega_min .AND. omega <= omega_max) then

            call eval_discrim(bp, state_ct(omega), discrim)

            mod_discrim = abs(discrim)

            stat = STAT_OK

         else

            stat = STAT_OMEGA_DOMAIN

         end if

         ! Finish

         return

      end subroutine eval_mod_discrim_

      subroutine report_stat_(stat, stage_str, n_iter, omega_a, omega_b, omega_c)

         integer, intent(in)      :: stat
         character(*), intent(in) :: stage_str
         integer, intent(in)      :: n_iter
         real(RD), intent(in)     :: omega_a
         real(RD), intent(in)     :: omega_b
         real(RD), intent(in)     :: omega_c

         ! Report the status

         if (check_log_level('WARN')) then

            write(OUTPUT_UNIT, 100) 'Failed during ', stage_str, ' : ', stat_str(stat)
100         format(4A)

         endif

         if (check_log_level('INFO')) then

            write(OUTPUT_UNIT, 110) 'n_iter  :', n_iter
110         format(3X,A,1X,I0)

            write(OUTPUT_UNIT, 120) 'omega_a :', real(x_a)
            write(OUTPUT_UNIT, 120) 'omega_b :', real(x_b)
            write(OUTPUT_UNIT, 120) 'omega_c :', real(x_c)
120         format(3X,A,1X,E24.16)

         end if

         ! Finish

         return

      end subroutine report_stat_

   end subroutine find_minima_

end module minmod_search_m
