! Module  : contour_search_m
! Purpose : mode searching (complex, contour)
!
! Copyright 2013-2025 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module contour_search_m

   ! Uses

   use forum_m, only: RD, reallocate

   use bvp_m
   use contour_map_m
   use discrim_m
   use ext_m
   use num_par_m
   use prox_search_m
   use state_m
   use status_m
   use sysmtx_m
   use util_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Derived-type definitions

   type :: isect_t
      complex(RD) :: omega_a
      complex(RD) :: omega_b
      integer     :: id
   end type isect_t

   ! Module variables

   integer, save :: id_m = 0

   interface reallocate
      module procedure reallocate_isect_t_1_
   end interface reallocate

   ! Access specifiers

   public :: contour_search

   ! Default access

   private

contains

   subroutine contour_search (bp, sm, omega_re, omega_im, omega_min, omega_max, i, nm_p, process_mode)

      class(bvp_ct), intent(in)       :: bp
      class(sysmtx_ct), intent(inout) :: sm
      real(RD), intent(in)            :: omega_re(:)
      real(RD), intent(in)            :: omega_im(:)
      real(RD), intent(in)            :: omega_min
      real(RD), intent(in)            :: omega_max
      integer, intent(in)             :: i
      type(num_par_t), intent(in)     :: nm_p
      interface
         subroutine process_mode(md, culled)
            use mode_m
            implicit none (type, external)
            type(mode_t), intent(in) :: md
            logical, intent(out)     :: culled
         end subroutine process_mode
      end interface

      type(ext_ct)               :: discrim(SIZE(omega_re),SIZE(omega_im))
      type(isect_t), allocatable :: is(:)

      ! Search for roots by finding zero-contour intersections as
      ! initial guesses, and then solve for modes

      ! The code below could be simplified using OMP IF clauses, but
      ! they seem to mess up inner parallel regions (all the code ends
      ! up running on one core)

      if (nm_p%parallel_scan) then

         !$OMP PARALLEL FIRSTPRIVATE(sm)
         call scan_discrim_(bp, sm, omega_re, omega_im, discrim)
         !$OMP END PARALLEL

      else

         call scan_discrim_(bp, sm, omega_re, omega_im, discrim)

      end if

      ! Find contour intersections

      call find_isects_(bp, sm, omega_re, omega_im, discrim, i, nm_p, is)

      ! Search for modes

      call prox_search(bp, sm, is%omega_a, is%omega_b, is%id, omega_min, omega_max, nm_p, process_mode)

      ! Finish

      return

   end subroutine contour_search

   !****

   subroutine scan_discrim_(bp, sm, omega_re, omega_im, discrim)

      class(bvp_ct), intent(in)       :: bp
      class(sysmtx_ct), intent(inout) :: sm
      real(RD), intent(in)            :: omega_re(:)
      real(RD), intent(in)            :: omega_im(:)
      type(ext_ct), intent(out)       :: discrim(:,:)

      integer     :: c_beg
      integer     :: c_end
      integer     :: c_rate
      integer     :: n_re
      integer     :: n_im
      integer     :: k
      integer     :: i
      integer     :: j
      complex(RD) :: omega

      @:CHECK_BOUNDS(SIZE(discrim, 1), SIZE(omega_re))
      @:CHECK_BOUNDS(SIZE(discrim, 2), SIZE(omega_im))

      ! Evaluate the discriminant at the frequency scan points

      !$OMP SINGLE
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 100) 'Evaluating discriminant'
100      format(A)
      endif
      !$OMP END SINGLE

      call SYSTEM_CLOCK(c_beg, c_rate)

      n_re = SIZE(omega_re)
      n_im = SIZE(omega_im)

      !$OMP DO PRIVATE(omega) COLLAPSE(2)
      discrim_im_loop: do j = 1, n_im
         discrim_re_loop: do i = 1, n_re

            omega = CMPLX(omega_re(i), omega_im(j), KIND=RD)

            call eval_discrim(bp, sm, state_ct(omega, omega_r=omega_re(i)), discrim(i,j))

         end do discrim_re_loop
      end do discrim_im_loop
      !$OMP END DO

      call SYSTEM_CLOCK(c_end)

      !$OMP SINGLE
      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 110) 'Time elapsed :', REAL(c_end-c_beg, RD)/c_rate, 's'
110      format(2X,A,F10.3,1X,A/)
      endif
      !$OMP END SINGLE

      ! Finish

      return

   end subroutine scan_discrim_

   !****

   subroutine find_isects_(bp, sm, omega_re, omega_im, discrim, i, nm_p, is)

      class(bvp_ct), intent(in)               :: bp
      class(sysmtx_ct), intent(inout)         :: sm
      real(RD), intent(in)                    :: omega_re(:)
      real(RD), intent(in)                    :: omega_im(:)
      type(ext_ct), intent(in)                :: discrim(:,:)
      integer, intent(in)                     :: i
      type(num_par_t), intent(in)             :: nm_p
      type(isect_t), allocatable, intent(out) :: is(:)

      integer             :: c_beg
      integer             :: c_end
      integer             :: c_rate
      type(contour_map_t) :: cm
      integer             :: n_is
      integer             :: d_is

      ! Find intersections between zero-contours of the discriminant

      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 100) 'Finding contour intersections'
100      format(A)
      endif

      ! Create the contour map and find intersections

      call SYSTEM_CLOCK(c_beg, c_rate)

      d_is = 128
      n_is = 0

      allocate(is(d_is))

      cm = contour_map_t(omega_re, omega_im, discrim, process_isect_)

      is = is(:n_is)

      call SYSTEM_CLOCK(c_end)

      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 120) 'Time elapsed :', REAL(c_end-c_beg, RD)/c_rate, 's'
120      format(2X,A,F10.3,1X,A/)
      endif

      ! Dump the map

      call cm%dump(nm_p, i)

      ! Finish

      return

   contains

      subroutine process_isect_(omega_a_re, omega_b_re, omega_a_im, omega_b_im)

         complex(RD), intent(in) :: omega_a_re
         complex(RD), intent(in) :: omega_b_re
         complex(RD), intent(in) :: omega_a_im
         complex(RD), intent(in) :: omega_b_im

         ! Process the intersection

         n_is = n_is + 1

         if (n_is > d_is) then
            d_is = 2*d_is
            call reallocate(is, [d_is])
         endif

         id_m = id_m + 1

         is(n_is)%omega_a = omega_init_(omega_a_re, omega_b_re, 'im')
         is(n_is)%omega_b = omega_init_(omega_a_im, omega_b_im, 're')

         is(n_is)%id = id_m

         ! Finish

         return

      end subroutine process_isect_

      !****

      function omega_init_(omega_a, omega_b, part) result(omega_init)

         complex(RD), intent(in)  :: omega_a
         complex(RD), intent(in)  :: omega_b
         character(*), intent(in) :: part
         complex(RD)              :: omega_init

         type(ext_ct) :: discrim_a
         type(ext_ct) :: discrim_b
         real(RD)     :: w

         ! Evaluate the discriminant at the segment endpoints

         call eval_discrim(bp, sm, state_ct(omega_a, omega_r=REAL(omega_a)), discrim_a)
         call eval_discrim(bp, sm, state_ct(omega_b, omega_r=REAL(omega_b)), discrim_b)

         ! Look for the point on the segment where the real/imaginary
         ! part of the discriminant changes sign

         select case (part)
         case ('re')
            w = real(-discrim_a%re/(discrim_b%re - discrim_a%re))
         case ('im')
            w = real(-discrim_a%im/(discrim_b%im - discrim_a%im))
         case default
            @:ABORT('Invalid part')
         end select

         omega_init = (1._RD-w)*omega_a + w*omega_b

         ! Finish

         return

      end function omega_init_

   end subroutine find_isects_

   !****

   $:REALLOCATE('type(isect_t)', 'isect_t', 1)

end module contour_search_m
