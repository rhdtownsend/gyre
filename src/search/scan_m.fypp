! Module  : scan_m
! Purpose : frequency scanning routines
!
! Copyright 2013-2025 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module scan_m

   ! Uses

   use forum_m, only: RD, unique_indices

   use context_m
   use freq_context_m
   use grid_m
   use mode_m
   use model_m
   use mode_par_m
   use osc_par_m
   use point_m
   use scan_par_m
   use util_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Access specifiers

   private

   public :: build_scan
   public :: check_scan

contains

   subroutine build_scan(cx, md_p, os_p, sc_p, axis, omega)

      type(context_t), intent(in)        :: cx
      type(mode_par_t), intent(in)       :: md_p
      type(osc_par_t), intent(in)        :: os_p
      type(scan_par_t), intent(in)       :: sc_p(:)
      character(*), intent(in)           :: axis
      real(RD), allocatable, intent(out) :: omega(:)

      integer :: i

      @:ASSERT(SIZE(sc_p)>=1, 'empty scan_par_t')

      ! Build the frequency scan

      if (check_log_level('INFO') .AND. COUNT(sc_p%axis == axis) > 0) then
         write(OUTPUT_UNIT, 100) 'Building frequency grid (', TRIM(axis), ' axis)'
100      format(A,A,A)
      endif

      ! Loop through scan_par_t

      allocate(omega(0))

      sc_p_loop : do i = 1,SIZE(sc_p)

         if (axis /= sc_p(i)%axis) cycle sc_p_loop

         select case (sc_p(i)%grid_type)
         case ('FILE')
            call build_scan_file_(cx, md_p, os_p, sc_p(i), omega)
         case default
            call build_scan_grid_(cx, md_p, os_p, sc_p(i), omega)
         end select

      end do sc_p_loop

      ! Sort and uniquify the frequencies

      if (SIZE(omega) > 0) then
         omega = omega(unique_indices(omega))
      end if

      if (check_log_level('INFO') .AND. COUNT(sc_p%axis == axis) > 0) then
         write(OUTPUT_UNIT, *)
      endif

      ! Finish

      return

   end subroutine build_scan

   !****

   subroutine build_scan_grid_(cx, md_p, os_p, sc_p, omega)

      type(context_t), intent(in)          :: cx
      type(mode_par_t), intent(in)         :: md_p
      type(osc_par_t), intent(in)          :: os_p
      type(scan_par_t), intent(in)         :: sc_p
      real(RD), allocatable, intent(inout) :: omega(:)

      real(RD)                :: omega_i_min
      real(RD)                :: omega_i_max
      real(RD)                :: omega_g_min
      real(RD)                :: omega_g_max
      real(RD)                :: omega_g
      real(RD), allocatable   :: omega_i(:)
      integer                 :: i

      ! Build the frequency scan as a grid

      ! Calculate the dimensionless frequency range in the inertial frame

      omega_i_min = sc_p%freq_min/freq_scale(sc_p%freq_min_units, cx, md_p, os_p) - &
         freq_shift(sc_p%freq_frame, cx, md_p)
      omega_i_max = sc_p%freq_max/freq_scale(sc_p%freq_max_units, cx, md_p, os_p) - &
         freq_shift(sc_p%freq_frame, cx, md_p)

      ! Build the scan

      if (sc_p%n_freq < 1) then

         if (check_log_level('INFO')) then
            write(OUTPUT_UNIT, 100) 'ignoring scan interval :', omega_i_min, ' -> ', omega_i_max, ' (n_freq < 1)'
100         format(3X,A,E11.4,A,E11.4,A)
         endif

      elseif (sc_p%n_freq == 1) then

         if (omega_i_max == omega_i_min) then

            omega = [omega,omega_i_min]

            if (check_log_level('INFO')) then
               write(OUTPUT_UNIT, 110) 'added scan point : ', omega_i_min
110            format(3X,A,E11.4)
            endif

         else

            if (check_log_level('INFO')) then
               write(OUTPUT_UNIT, 100) 'ignoring scan interval :', omega_i_min, ' -> ', omega_i_max, ' (n_freq == 1)'
            endif

         endif

      else

         if (omega_i_max > omega_i_min) then

            ! Calculate the dimensionless frequency range in the grid frame

            omega_g_min = omega_i_min + freq_shift(sc_p%grid_frame, cx, md_p)
            omega_g_max = omega_i_max + freq_shift(sc_p%grid_frame, cx, md_p)

            ! Set up the frequencies

            allocate(omega_i(sc_p%n_freq))

            do i = 1, sc_p%n_freq

               ! Grid frame

               select case(sc_p%grid_type)
               case('LINEAR')
                  omega_g = ((sc_p%n_freq-i)*omega_g_min + (i-1)*omega_g_max)/(sc_p%n_freq-1)
               case('INVERSE')
                  omega_g = (sc_p%n_freq-1)/((sc_p%n_freq-i)/omega_g_min + (i-1)/omega_g_max)
               case default
                  @:ABORT('invalid grid_type')
               end select

               ! Inertial frame

               omega_i(i) = omega_g - freq_shift(sc_p%grid_frame, cx, md_p)

            end do

            ! Store them

            omega = [omega,omega_i]

            if (check_log_level('INFO')) then
               write(OUTPUT_UNIT, 120) 'added scan interval : ', omega_i_min, ' -> ', omega_i_max, &
                  ' (', sc_p%n_freq, ' points, ', TRIM(sc_p%grid_type), ')'
120            format(3X,A,E11.4,A,E11.4,A,I0,A,A,A)
            endif

         else

            if (check_log_level('INFO')) then
               write(OUTPUT_UNIT, 120) 'ignoring scan interval :', omega_i_min, ' -> ', omega_i_max, ' (inverted)'
            endif

         endif

      endif

      ! Finish

      return

   end subroutine build_scan_grid_

   !****

   subroutine build_scan_file_(cx, md_p, os_p, sc_p, omega)

      type(context_t), intent(in)          :: cx
      type(mode_par_t), intent(in)         :: md_p
      type(osc_par_t), intent(in)          :: os_p
      type(scan_par_t), intent(in)         :: sc_p
      real(RD), allocatable, intent(inout) :: omega(:)

      integer                 :: unit
      integer                 :: n_freq
      real(RD), allocatable   :: freq(:)
      integer                 :: i
      real(RD), allocatable   :: omega_i(:)

      ! Build the frequency scan from file

      ! Open the frequency file

      open(NEWUNIT=unit, FILE=sc_p%file, STATUS='OLD')

      ! Count lines

      n_freq = 0

      count_loop : do
         read(unit, *, END=100)
         n_freq = n_freq + 1
      end do count_loop

100   continue

      ! Now read the data

      allocate(freq(n_freq))

      rewind(unit)

      read_loop : do i = 1, n_freq
         read(unit, *) freq(i)
      end do read_loop

      close(unit)

      ! Set up the frequencies

      omega_i = freq/freq_scale(sc_p%freq_units, cx, md_p, os_p) - freq_shift(sc_p%freq_frame, cx, md_p)

      ! Store them

      omega = [omega,omega_i]

      if (check_log_level('INFO')) then
         write(OUTPUT_UNIT, 110) 'added scan from file : ', TRIM(sc_p%file), &
            ' (', n_freq, ')'
110      format(3X,A,A,A,I0,A)
      endif

      ! Finish

      return

   end subroutine build_scan_file_

   !****

   subroutine check_scan(cx, gr, omega, md_p, os_p)

      class(context_t), intent(in) :: cx
      type(grid_t), intent(in)     :: gr
      real(RD), intent(inout)      :: omega(:)
      type(mode_par_t), intent(in) :: md_p
      type(osc_par_t), intent(in)  :: os_p

      real(RD) :: omega_min
      real(RD) :: omega_max
      real(RD) :: mOmega_rot_min
      real(RD) :: mOmega_rot_max
      integer  :: j
      real(RD) :: mOmega_rot
      real(RD) :: omega_c(4)

      ! Check the frequency scan to remove any points with leaky
      ! boundary conditions

      ! This needs to be done

      ! Check the frequency scan to ensure no zero crossings in omega_c
      ! arise

      if (SIZE(omega) >= 1) then

         associate(m => md_p%m)

            ! Determine the range of omega
         
            omega_min = MINVAL(omega)
            omega_max = MAXVAL(omega)

            ! For m = 0, a simple check suffices

            if (m == 0) then
               @:ASSERT(omega_min*omega_max > 0, 'critical layer encountered')
               return
            end if

            ! Determine the range of m*Omega_rot

            mOmega_rot_min = HUGE(0._RD)
            mOmega_rot_max = -HUGE(0._RD)

            do j = 1, gr%n
               mOmega_rot = m*cx%Omega_rot(gr%pt(j))
               mOmega_rot_min = MIN(mOmega_rot, mOmega_rot_min)
               mOmega_rot_max = MAX(mOmega_rot, mOmega_rot_max)
            end do

            ! Evaluate omega_c at the corners of the rectangle defined
            ! by the ranges in omega and m*Omega_rot

            omega_c(1) = omega_min - mOmega_rot_min
            omega_c(2) = omega_max - mOmega_rot_min
            omega_c(3) = omega_min - mOmega_rot_max
            omega_c(4) = omega_max - mOmega_rot_max

            ! Check that all omega_c have the same sign

            @:ASSERT(ALL(omega_c < 0._RD) .OR. ALL(omega_c > 0._RD), 'critical layer encountered')

         end associate

      end if
               
      ! Finish

      return

   end subroutine check_scan

end module scan_m
