! Module  : sblock_sysmtx_m
! Purpose : system matrix (block storage, serial implementation)
!
! Copyright 2013-2025 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module sblock_sysmtx_m

   ! Uses

   use forum_m, only: RD, hdf5io_t

   use ext_m
   use linalg_m
   use math_m
   use sysmtx_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   #:for T, S in zip(DTYPE_BASE_TYPES, DTYPE_SUFFIXES)

      ! Derived-type definitions

      type, extends(sysmtx_${S}$) :: sblock_sysmtx_${S}$
         private
         ${T}$, allocatable           :: G(:,:,:)  ! Left factor blocks
         ${T}$, allocatable           :: E(:,:,:)  ! Right factor blocks
         ${T}$, allocatable           :: R(:,:)    ! Reduced system matrix
         real(RD), allocatable        :: rscl(:)   ! Row scalings for pivoting
         type(ext_${S}$), allocatable :: scl(:)    ! Block scales
         ${T}$, allocatable           :: D(:)      ! Diagonal products
      contains
         private
         procedure         :: build_and_factor_E_ => build_and_factor_E_${S}$_
         procedure         :: build_and_factor_B_ => build_and_factor_B_${S}$_
         procedure         :: backsub_ => backsub_${S}$_
         procedure, public :: eval_det => eval_det_${S}$_
         procedure, public :: solve_hom => solve_hom_${S}$_
         procedure, public :: solve_inhom => solve_inhom_${S}$_
         procedure, public :: dump => dump_${S}$_
      end type sblock_sysmtx_${S}$

      ! Interfaces

      interface sblock_sysmtx_${S}$
         module procedure sblock_sysmtx_${S}$_
      end interface sblock_sysmtx_${S}$

      ! Access specifiers

      public :: sblock_sysmtx_${S}$

   #:endfor

   ! Default access

   private

contains

   #:for T, S in zip(DTYPE_BASE_TYPES, DTYPE_SUFFIXES)

      function sblock_sysmtx_${S}$_(n, n_e, n_i, n_o) result(sm)

         integer, intent(in)       :: n
         integer, intent(in)       :: n_e
         integer, intent(in)       :: n_i
         integer, intent(in)       :: n_o
         type(sblock_sysmtx_${S}$) :: sm

         @:CHECK_BOUNDS(n_i+n_o, n_e)

         ! Construct the sblock_sysmtx_t

         allocate(sm%G(n_e,n_e,n))
         allocate(sm%E(n_e,n_e,n))

         allocate(sm%scl(n))
         allocate(sm%rscl(n_e))

         allocate(sm%R(2*n_e,2*n_e))

         allocate(sm%D(n))

         sm%n = n
         sm%n_e = n_e
         sm%n_i = n_i
         sm%n_o = n_o

         ! Finish

         return

      end function sblock_sysmtx_${S}$_

      !****

      subroutine build_and_factor_E_${S}$_(this, eval_E, full)

         class(sblock_sysmtx_${S}$), intent(inout) :: this
         interface
            subroutine eval_E(k, E_l, E_r, scl)
               use forum_m, only: RD
               use ext_m
               implicit none (type, external)
               integer, intent(in)          :: k
               ${T}$, intent(out)           :: E_l(:,:)
               ${T}$, intent(out)           :: E_r(:,:)
               type(ext_${S}$), intent(out) :: scl
            end subroutine eval_E
         end interface
         logical, intent(in), optional :: full

         logical  :: full_
         integer  :: k
         ${T}$    :: G(2*this%n_e,this%n_e)
         ${T}$    :: U(2*this%n_e,this%n_e)
         ${T}$    :: E(2*this%n_e,this%n_e)
         integer  :: i
         real(RD) :: scl
         integer  :: s
         real(RD) :: rscl(2*this%n_e)
         integer  :: j
         real(RD) :: piv
         integer  :: i_piv
         ${T}$    :: alpha

         if(PRESENT(full)) then
            full_ = full
         else
            full_ = .FALSE.
         end if

         ! Build and factorize the equation blocks (steps following
         ! eqn. 2.4 of Wright 1994)

         associate (n => this%n, n_e => this%n_e, n_i => this%n_i, n_o => this%n_o)

            associate( &
               G_1 => G(:n_e,:), G_2 => G(n_e+1:,:), &
               U_1 => U(:n_e,:), U_2 => U(n_e+1:,:), &
               E_1 => E(:n_e,:), E_2 => E(n_e+1:,:), &
               rscl_1 => rscl(:n_e), rscl_2 => rscl(n_e+1:))

               call eval_E(1, G_1, U_1, this%scl(1))

               ! Determine row scalings for pivoting (first block)

               rscl_1 = 0._RD

               do s = 1, n_e
                  do i = 1, n_e
                     rscl_1(i) = MAX(rscl_1(i), abs(G_1(i,s)), abs(U_1(i,s)))
                  end do
               end do

               rscl_1 = 1._RD/rscl_1

               ! Process pairs of blocks

               block_loop : do k = 1, n-1

                  call eval_E(k+1, U_2, E_2, this%scl(k+1))

                  G_2 = 0._RD
                  E_1 = 0._RD

                  ! Determine row scalings for pivoting

                  rscl_2 = 0._RD

                  do s = 1, n_e
                     do i = 1, n_e
                        rscl_2(i) = MAX(rscl_2(i), abs(U_2(i,s)), abs(E_2(i,s)))
                     end do
                  end do

                  rscl_2 = 1._RD/rscl_2

                  ! Reduce U to row echelon form

                  this%D(k) = 1._RD

                  reduce_loop: do j = 1, n_e

                     ! Find the pivot row

                     piv = 0._RD
                     i_piv = j

                     do i = j, 2*n_e
                        scl = abs(U(i,j))*rscl(i)
                        if (scl > piv) then
                           piv = scl
                           i_piv = i
                        end if
                     end do

                     @:ASSERT_DEBUG(piv /= 0._RD, 'zero pivot')

                     ! If necessary, swap rows to place the pivot
                     ! on the diagonal

                     if (i_piv /= j) then

                        do s = 1, n_e

                           alpha = G(i_piv,s)
                           G(i_piv,s) = G(j,s)
                           G(j,s) = alpha

                           alpha = U(i_piv,s)
                           U(i_piv,s) = U(j,s)
                           U(j,s) = alpha

                           alpha = E(i_piv,s)
                           E(i_piv,s) = E(j,s)
                           E(j,s) = alpha

                        end do

                        scl = rscl(i_piv)
                        rscl(i_piv) = rscl(j)
                        rscl(j) = scl

                        this%D(k) = -this%D(k)

                     end if

                     ! Scale the row so that the diagonal element
                     ! is unity

                     this%D(k) = this%D(k)*U(j,j)

                     alpha = 1._RD/U(j,j)

                     do s = 1, n_e
                        G(j,s) = alpha*G(j,s)
                        U(j,s) = alpha*U(j,s)
                        E(j,s) = alpha*E(j,s)
                     end do

                     ! Eliminate elements below the diagonal

                     do i = j+1, 2*n_e
                        alpha = U(i,j)
                        do s = 1, n_e
                           G(i,s) = G(i,s) - alpha*G(j,s)
                           U(i,s) = U(i,s) - alpha*U(j,s)
                           E(i,s) = E(i,s) - alpha*E(j,s)
                        end do
                     end do

                     ! Eliminate elements above the diagonal. This is
                     ! skipped if full is not .TRUE.

                     if (full_) then

                        do i = 1, j-1
                           alpha = U(i,j)
                           do s = 1, n_e
                              G(i,s) = G(i,s) - alpha*G(j,s)
                              U(i,s) = U(i,s) - alpha*U(j,s)
                              E(i,s) = E(i,s) - alpha*E(j,s)
                           end do
                        end do

                     end if

                  end do reduce_loop

                  ! Store data for backsubstitution

                  if (full_) then

                     this%G(:,:,k) = G_1
                     this%E(:,:,k) = E_1

                  end if

                  ! Prepare for the next block

                  G_1 = G_2
                  U_1 = E_2

                  rscl_1 = rscl_2

               end do block_loop

               ! Store final values

               this%G(:,:,n) = G_2
               this%E(:,:,n) = E_2

               this%rscl = rscl_2

            end associate

         end associate

         ! Finish

         return

      end subroutine build_and_factor_E_${S}$_

      !****

      subroutine build_and_factor_B_${S}$_(this, eval_B, full, f)

         class(sblock_sysmtx_${S}$), intent(inout) :: this
         interface
            subroutine eval_B(B_i, B_o, scl_i, scl_o)
               use forum_m, only: RD
               implicit none (type, external)
               ${T}$, intent(out) :: B_i(:,:)
               ${T}$, intent(out) :: B_o(:,:)
               ${T}$, intent(out) :: scl_i(:)
               ${T}$, intent(out) :: scl_o(:)
            end subroutine eval_B
         end interface
         logical, intent(in), optional  :: full
         ${T}$, intent(inout), optional :: f(:)

         logical  :: full_
         ${T}$    :: R(2*this%n_e,2*this%n_e)
         ${T}$    :: scl_i(this%n_i)
         ${T}$    :: scl_o(this%n_o)
         integer  :: s
         integer  :: i
         real(RD) :: scl
         real(RD) :: rscl(2*this%n_e)
         integer  :: j
         real(RD) :: piv
         integer  :: i_piv
         ${T}$    :: alpha

         if(PRESENT(full)) then
            full_ = full
         else
            full_ = .FALSE.
         end if

         if(PRESENT(f)) then
            @:CHECK_BOUNDS(SIZE(f), 2*this%n_e)
         end if

         ! Build and factorize the boundary blocks (eqn. 2.8 of Wright 1994)

         associate (n => this%n, n_e => this%n_e, n_i => this%n_i, n_o => this%n_o)

            associate( &
               R_1 => R(:n_e,:), R_2 => R(n_e+1:,:), &
               rscl_1 => rscl(:n_e), rscl_2 => rscl(n_e+1:), &
               f_1 => f(:n_e), f_2 => f(n_e+1:))

               R_1(:,:n_e) = this%G(:,:,n)
               R_1(:,n_e+1:) = this%E(:,:,n)

               call eval_B(R_2(:n_i,:n_e), R_2(n_i+1:,n_e+1:), scl_i, scl_o)

               R_2(:n_i,n_e+1:) = 0._RD
               R_2(n_i+1:,:n_e) = 0._RD

               if (PRESENT(f)) then
                  f_2(:n_i) = f_2(:n_i)/scl_i
                  f_2(n_i+1:) = f_2(n_i+1:)/scl_o
               end if

               ! Determine row scalings for pivoting

               rscl_1 = this%rscl

               rscl_2 = 0._RD

               do s = 1, 2*n_e
                  do i = 1, n_e
                     rscl_2(i) = MAX(rscl_2(i), abs(R_2(i,s)))
                  end do
               end do

               rscl_2 = 1._RD/rscl_2

               ! Reduce R to row echelon form

               this%D(n) = 1._RD

               reduce_loop: do j = 1, 2*n_e

                  ! Find the pivot

                  piv = 0._RD
                  i_piv = j

                  do i = j, 2*n_e
                     scl = abs(R(i,j))*rscl(i)
                     if (scl > piv) then
                        piv = scl
                        i_piv = i
                     end if
                  end do

                  ! If the pivot is zero, then skip this column

                  if (piv == 0._RD) then
                     this%D(n) = 0._RD
                     print *,'skip col'
                     cycle reduce_loop
                  end if

                  ! If necessary, swap rows to place the pivot
                  ! on the diagonal

                  if (i_piv /= j) then

                     do s = 1, 2*n_e
                        alpha = R(i_piv,s)
                        R(i_piv,s) = R(j,s)
                        R(j,s) = alpha
                     end do

                     scl = rscl(i_piv)
                     rscl(i_piv) = rscl(j)
                     rscl(j) = scl

                     this%D(n) = -this%D(n)

                     if (PRESENT(f)) then
                        alpha = f(i_piv)
                        f(i_piv) = f(j)
                        f(j) = alpha
                     end if

                  end if

                  ! (Unlike above, don't scale the row so that the
                  ! diagonal element is unity, because this element might
                  ! be zero)

                  this%D(n) = this%D(n)*R(j,j)

                  ! Eliminate elements below the diagonal

                  do i = j+1, 2*n_e

                     alpha = R(i,j)/R(j,j)
                     do s = 1, 2*n_e
                        R(i,s) = R(i,s) - alpha*R(j,s)
                     end do

                     if (PRESENT(f)) then
                        f(i) = f(i) - alpha*f(j)
                     end if

                  end do

               end do reduce_loop

               ! Store data for backsubstitution

               if (full_) then
                  this%R = R
               end if

            end associate

         end associate

         ! Finish

         return

      end subroutine build_and_factor_B_${S}$_

      !****

      subroutine backsub_${S}$_(this, u_bound, u)

         class(sblock_sysmtx_${S}$), intent(in) :: this
         ${T}$, intent(in)                      :: u_bound(:)
         ${T}$, intent(out)                     :: u(:)

         integer :: k

         @:CHECK_BOUNDS(SIZE(u_bound), 2*this%n_e)
         @:CHECK_BOUNDS(SIZE(u), this%n_e*(this%n+1))

         ! Given the solution vector u_bound at the boundaries,
         ! backsubstitute to reconstruct the full solution vector u

         associate (n => this%n, n_e => this%n_e, n_i => this%n_i)

            u(:n_e) = u_bound(:n_e)
            u(n_e*n+1:) = u_bound(n_e+1:)

            backsub_loop : do k = n, 2, -1

               associate(u_1 => u(:n_e), u_k => u(n_e*(k-1)+1:n_e*k), u_k1 => u(n_e*k+1:n_e*(k+1)))

                  u_k = -MATMUL(this%G(:,:,k-1), u_1) - MATMUL(this%E(:,:,k-1), u_k1)

               end associate

            end do backsub_loop

         end associate

         ! Finish

         return

      end subroutine backsub_${S}$_

      !****

      subroutine eval_det_${S}$_(this, eval_B, eval_E, det)

         class(sblock_sysmtx_${S}$), intent(inout) :: this
         interface
            subroutine eval_B(B_i, B_o, scl_i, scl_o)
               use forum_m, only: RD
               implicit none (type, external)
               ${T}$, intent(out) :: B_i(:,:)
               ${T}$, intent(out) :: B_o(:,:)
               ${T}$, intent(out) :: scl_i(:)
               ${T}$, intent(out) :: scl_o(:)
            end subroutine eval_B
            subroutine eval_E(k, E_l, E_r, scl)
               use forum_m, only: RD
               use ext_m
               implicit none (type, external)
               integer, intent(in)          :: k
               ${T}$, intent(out)           :: E_l(:,:)
               ${T}$, intent(out)           :: E_r(:,:)
               type(ext_${S}$), intent(out) :: scl
            end subroutine eval_E
         end interface
         type(ext_${S}$), intent(out) :: det

         ! Build and factorize the sysmtx

         call this%build_and_factor_E_(eval_E)
         call this%build_and_factor_B_(eval_B)

         ! Evaluate the determinant

!         det = product([ext_${S}$(this%D),ext_${S}$(this%scl_i),this%scl,ext_${S}$(this%scl_o)])
         det = product([ext_${S}$(this%D),this%scl])

         ! Finish

         return

      end subroutine eval_det_${S}$_

      !****

      subroutine solve_hom_${S}$_(this, eval_B, eval_E, u)

         class(sblock_sysmtx_${S}$), intent(inout) :: this
         interface
            subroutine eval_B(B_i, B_o, scl_i, scl_o)
               use forum_m, only: RD
               implicit none (type, external)
               ${T}$, intent(out) :: B_i(:,:)
               ${T}$, intent(out) :: B_o(:,:)
               ${T}$, intent(out) :: scl_i(:)
               ${T}$, intent(out) :: scl_o(:)
            end subroutine eval_B
            subroutine eval_E(k, E_l, E_r, scl)
               use forum_m, only: RD
               use ext_m
               implicit none (type, external)
               integer, intent(in)          :: k
               ${T}$, intent(out)           :: E_l(:,:)
               ${T}$, intent(out)           :: E_r(:,:)
               type(ext_${S}$), intent(out) :: scl
            end subroutine eval_E
         end interface
         ${T}$, intent(out) :: u(:)

         real(RD) :: R_s
         integer  :: i
         integer  :: i_s
         ${T}$    :: u_bound(2*this%n_e)
         integer  :: j
         ${T}$    :: beta

         @:CHECK_BOUNDS(SIZE(u), this%n_e*(this%n+1))

         ! Build and factorize the sysmtx

         call this%build_and_factor_E_(eval_E, full=.TRUE.)
         call this%build_and_factor_B_(eval_B, full=.TRUE.)

         ! Evaluate the solution vector u of the homogeneous linear system
         ! S u = 0. It is assumed that the nullity nul(S) == 1

         associate (n => this%n, n_e => this%n_e, n_i => this%n_i)

            R_s = HUGE(0._RD)

            sing_loop : do i = n_e+1, 2*n_e
               if (abs(this%R(i,i)) < R_s) then
                  R_s = abs(this%R(i,i))
                  i_s = i
               end if
            end do sing_loop

            ! Use backsubstitution to solve for u_bound

            u_bound(i_s) = 1._RD
            u_bound(i_s+1:) = 0._RD

            do i = i_s-1, 1, -1
               beta = 0._RD
               do j = i+1, i_s
                  beta = beta + this%R(i,j)*u_bound(j)
               end do
               u_bound(i) = -beta/this%R(i,i)
            end do

         end associate

         ! Backsubstitute to reconstruct the full solution vector

         call this%backsub_(u_bound, u)

         ! Finish

         return

      end subroutine solve_hom_${S}$_

      !****

      subroutine solve_inhom_${S}$_(this, eval_B, eval_E, v, u)

         class(sblock_sysmtx_${S}$), intent(inout) :: this
         interface
            subroutine eval_B(B_i, B_o, scl_i, scl_o)
               use forum_m, only: RD
               implicit none (type, external)
               ${T}$, intent(out) :: B_i(:,:)
               ${T}$, intent(out) :: B_o(:,:)
               ${T}$, intent(out) :: scl_i(:)
               ${T}$, intent(out) :: scl_o(:)
            end subroutine eval_B
            subroutine eval_E(k, E_l, E_r, scl)
               use forum_m, only: RD
               use ext_m
               implicit none (type, external)
               integer, intent(in)          :: k
               ${T}$, intent(out)           :: E_l(:,:)
               ${T}$, intent(out)           :: E_r(:,:)
               type(ext_${S}$), intent(out) :: scl
            end subroutine eval_E
         end interface
         ${T}$, intent(in)  :: v(:)
         ${T}$, intent(out) :: u(:)

         ${T}$   :: f(2*this%n_e)
         integer :: i
         ${T}$   :: u_bound(2*this%n_e)
         ${T}$   :: beta
         integer :: j

         @:CHECK_BOUNDS(SIZE(v), this%n_e)

         @:CHECK_BOUNDS(SIZE(u), this%n_e*(this%n+1))

         ! Build and factorize the sysmtx

         f(:this%n_e) = 0._RD
         f(this%n_e+1:) = v

         call this%build_and_factor_E_(eval_E, full=.TRUE.)
         call this%build_and_factor_B_(eval_B, full=.TRUE., f=f)

         ! Evaluate the solution vector v of the inhomogeneous linear
         ! system S u = v. It is assumed that the right-hand side
         ! vector v has non-zero components in only the n_i first and
         ! n_o last rows (corresponding to the inner and outer
         ! boundary conditions). These components are supplied in
         ! v(:n_i) and v(n_i+1:), respectively.

         associate (n => this%n, n_e => this%n_e, n_i => this%n_i)

            ! Use backsubstitution to solve for u_bound

            u_bound(2*n_e) = f(2*n_e)/this%R(2*n_e,2*n_e)

            do i = 2*n_e-1, 1, -1
               beta = 0._RD
               do j = i+1, 2*n_e
                  beta = beta + this%R(i,j)*u_bound(j)
               end do
               u_bound(i) = (f(i) - beta)/this%R(i,i)
            end do

         end associate

         ! Backsubstitute to reconstruct the full solution vector

         call this%backsub_(u_bound, u)

         ! Finish

         return

      end subroutine solve_inhom_${S}$_

      !****

      subroutine dump_${S}$_(this, hi)

         class(sblock_sysmtx_${S}$), intent(in) :: this
         type(hdf5io_t), intent(inout)          :: hi

         ! Dump the sblock_sysmtx_t to the hgroup

         call hi%write_attr('n', this%n)
         call hi%write_attr('n_e', this%n_e)
         call hi%write_attr('n_i', this%n_i)
         call hi%write_attr('n_o', this%n_o)

!         call hi%write_dset('scl_i', this%scl_i)
!         call hi%write_dset('scl_o', this%scl_o)

         call hi%write_dset('G', this%G)
         call hi%write_dset('E', this%E)

         call hi%write_dset('R', this%R)

         call hi%write_dset('scl_f', FRACTION(this%scl))
         call hi%write_dset('scl_e', EXPONENT(this%scl))

         ! Finish

         return

      end subroutine dump_${S}$_

   #:endfor

end module sblock_sysmtx_m
