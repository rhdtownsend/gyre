! Module  : band_sysmtx_m
! Purpose : system matrix (band storage)
!
! Copyright 2013-2025 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module band_sysmtx_m

   ! Uses

   use forum_m, only: RD, hdf5io_t

   use blas_lapack_m
   use ext_m
   use linalg_m
   use math_m
   use sysmtx_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   #:for T, S in zip(DTYPE_BASE_TYPES, DTYPE_SUFFIXES)

      ! Derived-type definitions

      type, extends(sysmtx_${S}$) :: band_sysmtx_${S}$
         private
         ${T}$, allocatable           :: A_b(:,:)  ! Banded matrix
         integer, allocatable         :: ipiv(:)   ! Pivot indices
         ${T}$, allocatable           :: scl_i(:)  ! Inner boundary scales
         ${T}$, allocatable           :: scl_o(:)  ! Outer boundary scales
         type(ext_${S}$), allocatable :: scl(:)    ! Block scales
         integer                      :: n_l       ! Number of sub-diagonals
         integer                      :: n_u       ! Number of super-diagonals
      contains
         private
         procedure         :: set_row_ => set_row_${S}$_
         procedure         :: get_row_ => get_row_${S}$_
         procedure         :: build_and_factor_ => build_and_factor_${S}$_
         procedure, public :: eval_det => eval_det_${S}$_
         procedure, public :: solve_hom => solve_hom_${S}$_
         procedure, public :: solve_inhom => solve_inhom_${S}$_
         procedure, public :: dump => dump_${S}$_
      end type band_sysmtx_${S}$

      ! Interfaces

      interface band_sysmtx_${S}$
         module procedure band_sysmtx_${S}$_
      end interface band_sysmtx_${S}$

      ! Access specifiers

      public :: band_sysmtx_${S}$

   #:endfor

   ! Default access

   private

contains

   #:for T, S in zip(DTYPE_BASE_TYPES, DTYPE_SUFFIXES)

      function band_sysmtx_${S}$_(n, n_e, n_i, n_o) result(sm)

         integer, intent(in)     :: n
         integer, intent(in)     :: n_e
         integer, intent(in)     :: n_i
         integer, intent(in)     :: n_o
         type(band_sysmtx_${S}$) :: sm

         ! Construct the sysmtx type

         ! Note that an additional n_l rows are added to A_b to
         ! provide space for fill-in during factorization. See e.g.
         ! https://www.netlib.org/lapack/lug/node124.html

         sm%n_l = n_e + n_i - 1
         sm%n_u = n_e + n_o - 1

         allocate(sm%A_b(2*sm%n_l+sm%n_u+1,n_e*(n+1)))
         allocate(sm%ipiv(n_e*(n+1)))

         allocate(sm%scl_i(n_i))
         allocate(sm%scl_o(n_o))

         allocate(sm%scl(n))

         sm%n = n
         sm%n_e = n_e
         sm%n_i = n_i
         sm%n_o = n_o

         ! Finish

         return

      end function band_sysmtx_${S}$_

      !****

      subroutine set_row_${S}$_(this, i_0, j_0, R)

         class(band_sysmtx_${S}$), intent(inout) :: this
         integer, intent(in)                     :: i_0
         integer, intent(in)                     :: j_0
         ${T}$, intent(in)                       :: R(:)

         integer :: j
         integer :: i_b

         @:ASSERT_DEBUG(i_0-j_0 <= this%n_l, 'invalid indices')
         @:ASSERT_DEBUG(i_0-(j_0+SIZE(R)-1) <= this%n_l, 'invalid indices')

         @:ASSERT_DEBUG(j_0-i_0 <= this%n_u, 'invalid indices')
         @:ASSERT_DEBUG((j_0+SIZE(R)-1)-i_0 <= this%n_u, 'invalid indices')

         ! Set data in row i_0, starting at column j_0. The rest of the row
         ! is zeroed out

         i_b = this%n_l + this%n_u + 1 + i_0 - MAX(i_0-this%n_l, 1)

         do j = MAX(i_0-this%n_l, 1), j_0-1
            this%A_b(i_b, j) = 0._RD
            i_b = i_b - 1
         end do

         do j = j_0, j_0+SIZE(R)-1
            this%A_b(i_b, j) = R(j-j_0+1)
            i_b = i_b - 1
         end do

         do j = j_0+SIZE(R), MIN(i_0+this%n_u, this%n_e*(this%n+1))
            this%A_b(i_b, j) = 0._RD
            i_b = i_b - 1
         end do

         ! Finish

         return

      end subroutine set_row_${S}$_

      !****

      subroutine get_row_${S}$_(this, i_0, j_0, R)

         class(band_sysmtx_${S}$), intent(in) :: this
         integer, intent(in)                  :: i_0
         integer, intent(in)                  :: j_0
         ${T}$, intent(out)                   :: R(:)

         integer :: j
         integer :: i_b
         integer :: j_b

         @:ASSERT_DEBUG(i_0-j_0 <= this%n_l, 'invalid indices')
         @:ASSERT_DEBUG(i_0-(j_0+SIZE(R)-1) <= this%n_l, 'invalid indices')

         @:ASSERT_DEBUG(j_0-i_0 <= this%n_u, 'invalid indices')
         @:ASSERT_DEBUG((j_0+SIZE(R)-1)-i_0 <= this%n_u, 'invalid indices')

         ! Get data from row i_0, starting at column j_0

         do j = j_0, j_0+SIZE(R)-1
            i_b = this%n_l + this%n_u + 1 + i_0 - j
            j_b = j
            R(j-j_0+1) = this%A_b(i_b, j_b)
         end do

         ! Finish

         return

      end subroutine get_row_${S}$_

      !****

      subroutine build_and_factor_${S}$_(this, eval_B, eval_E)

         class(band_sysmtx_${S}$), intent(inout) :: this
         interface
            subroutine eval_B(B_i, B_o)
               use forum_m, only: RD
               implicit none (type, external)
               ${T}$, intent(out) :: B_i(:,:)
               ${T}$, intent(out) :: B_o(:,:)
            end subroutine eval_B
            subroutine eval_E(k, E_l, E_r, scl)
               use forum_m, only: RD
               use ext_m
               implicit none (type, external)
               integer, intent(in)          :: k
               ${T}$, intent(out)           :: E_l(:,:)
               ${T}$, intent(out)           :: E_r(:,:)
               type(ext_${S}$), intent(out) :: scl
            end subroutine eval_E
         end interface

         ${T}$   :: B_i(this%n_i,this%n_e)
         ${T}$   :: B_o(this%n_i,this%n_e)
         ${T}$   :: E_l(this%n_e,this%n_e)
         ${T}$   :: E_r(this%n_e,this%n_e)
         ${T}$   :: R(2*this%n_e)
         integer :: i
         ${T}$   :: scl
         integer :: k
         integer :: info

         ! Build and factorize the sysmtx

         associate (n => this%n, n_e => this%n_e, n_i => this%n_i, n_o => this%n_o)

            ! Build the boundary blocks, and row-scale to unity

            call eval_B(B_i, B_o)
            do i = 1, n_i
               scl = MAXVAL(abs(B_i(i,:)))
               this%scl_i(i) = scl
               call this%set_row_(i, 1, B_i(i,:)/scl)
            end do
            do i = 1, n_o
               scl = MAXVAL(abs(B_o(i,:)))
               this%scl_o(i) = scl
               call this%set_row_(n_e*n+n_i+i, n_e*n+1, B_o(i,:)/scl)
            end do

            ! Build the equation blocks, and row-scale to unity

            !$OMP PARALLEL

            !$OMP DO PRIVATE(E_l, E_r, i, R, scl)
            do k = 1, n
               call eval_E(k, E_l, E_r, this%scl(k))
               do i = 1, n_e
                  R = [E_l(i,:),E_r(i,:)]
                  scl = MAXVAL(abs(R))
                  this%scl(k) = this%scl(k)*scl
                  call this%set_row_(n_e*(k-1)+n_i+i, n_e*(k-1)+1, R/scl)
               end do
            end do
            !$OMP END DO

            !$OMP END PARALLEL

            ! Factorize the sysmtx using banded LU decomposition

            call XGBTRF(SIZE(this%A_b, 2), SIZE(this%A_b, 2), this%n_l, this%n_u, &
               this%A_b, SIZE(this%A_b, 1), this%ipiv, info)
            @:ASSERT(info == 0 .OR. info > -this%n_e, 'non-zero return from XGBTRF')

         end associate

         ! Finish

         return

      end subroutine build_and_factor_${S}$_

      !****

      subroutine eval_det_${S}$_(this, eval_B, eval_E, det)

         class(band_sysmtx_${S}$), intent(inout) :: this
         interface
            subroutine eval_B(B_i, B_o)
               use forum_m, only: RD
               implicit none (type, external)
               ${T}$, intent(out) :: B_i(:,:)
               ${T}$, intent(out) :: B_o(:,:)
            end subroutine eval_B
            subroutine eval_E(k, E_l, E_r, scl)
               use forum_m, only: RD
               use ext_m
               implicit none (type, external)
               integer, intent(in)          :: k
               ${T}$, intent(out)           :: E_l(:,:)
               ${T}$, intent(out)           :: E_r(:,:)
               type(ext_${S}$), intent(out) :: scl
            end subroutine eval_E
         end interface
         type(ext_${S}$), intent(out) :: det

         integer :: j

         ! Build and factorize the sysmtx

         call this%build_and_factor_(eval_B, eval_E)

         ! Evaluate the determinant

         det = product_${S}$(this%A_b(this%n_l+this%n_u+1,:))* &
            product([ext_${S}$(this%scl_i),this%scl,ext_${S}$(this%scl_o)])

         do j = 1, SIZE(this%ipiv)
            if(this%ipiv(j) /= j) det = -det
         enddo

         ! Finish

         return

      end subroutine eval_det_${S}$_

      !****

      subroutine solve_hom_${S}$_(this, eval_B, eval_E, u)

         class(band_sysmtx_${S}$), intent(inout) :: this
         interface
            subroutine eval_B(B_i, B_o)
               use forum_m, only: RD
               implicit none (type, external)
               ${T}$, intent(out) :: B_i(:,:)
               ${T}$, intent(out) :: B_o(:,:)
            end subroutine eval_B
            subroutine eval_E(k, E_l, E_r, scl)
               use forum_m, only: RD
               use ext_m
               implicit none (type, external)
               integer, intent(in)          :: k
               ${T}$, intent(out)           :: E_l(:,:)
               ${T}$, intent(out)           :: E_r(:,:)
               type(ext_${S}$), intent(out) :: scl
            end subroutine eval_E
         end interface
         ${T}$, intent(out) :: u(:)

         integer              :: i_s
         real(RD)             :: A_s
         integer              :: i
         ${T}$, allocatable   :: A_b(:,:)
         ${T}$, allocatable   :: B(:,:)
         integer, allocatable :: ipiv(:)
         integer              :: n2
         integer              :: j
         integer              :: info

         @:CHECK_BOUNDS(SIZE(u), this%n_e*(this%n+1))

         ! Build and factorize the sysmtx

         call this%build_and_factor_(eval_B, eval_E)

         ! Evaluate the solution vector u of the homogeneous linear system
         ! S u = 0. It is assumed that the nullity nul(S) >= 1

         associate (n => this%n, n_e => this%n_e, n_l => this%n_l, n_u => this%n_u)

            ! Locate the smallest element on the diagonal of the outer
            ! block (this will be taken to be the singular element)

            i_s = 0
            A_s = HUGE(0._RD)

            sing_loop : do i = n_e*n+1, n_e*(n+1)
               if (abs(this%A_b(n_l+n_u+1,i)) < A_s) then
                  A_s = abs(this%A_b(n_l+n_u+1,i))
                  i_s = i
               end if
            end do sing_loop

            ! Set up the reduced banded system

            allocate(A_b(2*n_l+n_u+1,i_s-1))
            allocate(B(i_s-1,1))

            allocate(ipiv(i_s-1))

            A_b(:n_l+n_u+1,:) = this%A_b(:n_l+n_u+1,:i_s-1)
            A_b(n_l+n_u+2:,:) = 0._RD

            n2 = MIN(n_l+n_u, i_s-1)

            B(:i_s-n2-1,1) = 0._RD
            B(i_s-n2:,1) = -this%A_b(n_l+n_u+1-n2:n_l+n_u,i_s)

            do j = 1,i_s-1
               ipiv(j) = j
            enddo

            ! Solve for the 1:i_s-1 components of the solution vector

            call XGBTRS('N', SIZE(A_b, 2), n_l, n_u, 1, A_b, SIZE(A_b, 1), ipiv, B, SIZE(B, 1), info)
            @:ASSERT(info == 0, 'non-zero return from XGBTRS')

            u(:i_s-1) = B(:,1)

         end associate

         ! Fill in the remaining components of the solution vector

         u(i_s) = 1._RD
         u(i_s+1:) = 0._RD

         ! Finish

         return

      end subroutine solve_hom_${S}$_

      !****

      subroutine solve_inhom_${S}$_(this, eval_B, eval_E, v, u)

         class(band_sysmtx_${S}$), intent(inout) :: this
         interface
            subroutine eval_B(B_i, B_o)
               use forum_m, only: RD
               implicit none (type, external)
               ${T}$, intent(out) :: B_i(:,:)
               ${T}$, intent(out) :: B_o(:,:)
            end subroutine eval_B
            subroutine eval_E(k, E_l, E_r, scl)
               use forum_m, only: RD
               use ext_m
               implicit none (type, external)
               integer, intent(in)          :: k
               ${T}$, intent(out)           :: E_l(:,:)
               ${T}$, intent(out)           :: E_r(:,:)
               type(ext_${S}$), intent(out) :: scl
            end subroutine eval_E
         end interface
         ${T}$, intent(in)  :: v(:)
         ${T}$, intent(out) :: u(:)

         ${T}$   :: B(this%n_e*(this%n+1),1)
         integer :: info

         @:CHECK_BOUNDS(SIZE(v), this%n_e)

         @:CHECK_BOUNDS(SIZE(u), this%n_e*(this%n+1))

         ! Build and factorize the sysmtx

         call this%build_and_factor_(eval_B, eval_E)

         ! Evaluate the solution vector u of the inhomogeneous linear
         ! system S u = v. It is assumed that the right-hand side vector v
         ! has non-zero components in only the n_i first and n_o last rows
         ! (corresponding to the inner and outer boundary
         ! conditions). These components are supplied in v_i and v_o,
         ! respectively.

         associate (n => this%n, n_e => this%n_e, n_i => this%n_i, n_l => this%n_l, n_u => this%n_u)

            ! Set up the banded system

            B(:n_i,1) = v(:n_i)/this%scl_i
            B(n_i+1:n_i+n*n_e,1) = 0._RD
            B(n_i+n*n_e+1:,1) = v(n_i+1:)/this%scl_o

            ! Solve for u

            call XGBTRS('N', n_e*(n+1), n_l, n_u, 1, &
               this%A_b, SIZE(this%A_b, 1), this%ipiv, B, n_e*(n+1), info)
            @:ASSERT(info == 0, 'non-zero return from XGBTRS')

            u = B(:,1)

         end associate

         ! Finish

         return

      end subroutine solve_inhom_${S}$_

      !****

      subroutine dump_${S}$_(this, hi)

         class(band_sysmtx_${S}$), intent(in) :: this
         type(hdf5io_t), intent(inout)        :: hi

         ${T}$, allocatable :: E_l(:,:,:)
         ${T}$, allocatable :: E_r(:,:,:)
         ${T}$, allocatable :: B_i(:,:)
         ${T}$, allocatable :: B_o(:,:)
         integer            :: i
         integer            :: k

         ! Dump the band_sysmtx_t to the hgroup

         call hi%write_attr('n', this%n)
         call hi%write_attr('n_e', this%n_e)
         call hi%write_attr('n_i', this%n_i)
         call hi%write_attr('n_o', this%n_o)

         associate (n => this%n, &
            n_e => this%n_e, &
            n_i => this%n_i, &
            n_o => this%n_o)

            allocate(E_l(n_e,n_e,n))
            allocate(E_r(n_e,n_e,n))

            allocate(B_i(n_i,n_e))
            allocate(B_o(n_o,n_e))

            do i = 1, n_i
               call this%get_row_(i, 1, B_i(i,:))
            end do

            block_loop: do k = 1, n
               do i = 1, n_e
                  call this%get_row_((k-1)*n_e+i+n_i, (k-1)*n_e+1, E_l(i,:,k))
                  call this%get_row_((k-1)*n_e+i+n_i,  k   *n_e+1, E_r(i,:,k))
               end do
            end do block_loop

            do i = 1, n_o
               call this%get_row_(n*n_e+i+n_i, n*n_e+1, B_o(i,:))
            end do

         end associate

         call hi%write_dset('B_i', B_i)
         call hi%write_dset('scl_i', this%scl_i)

         call hi%write_dset('B_o', B_o)
         call hi%write_dset('scl_o', this%scl_o)

         call hi%write_dset('E_l', E_l)
         call hi%write_dset('E_r', E_r)

         #:if T == 'complex(RD)'

         call hi%write_dset('scl_re_f', fraction(this%scl%re))
         call hi%write_dset('scl_re_e', exponent(this%scl%im))

         call hi%write_dset('scl_im_f', fraction(this%scl%re))
         call hi%write_dset('scl_im_e', exponent(this%scl%im))

         #:else

         call hi%write_dset('scl_re_f', fraction(this%scl))
         call hi%write_dset('scl_re_e', exponent(this%scl))

         #:endif

         ! Finish

         return

      end subroutine dump_${S}$_

   #:endfor

end module band_sysmtx_m
