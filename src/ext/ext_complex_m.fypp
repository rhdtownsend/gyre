! Module  : ext_complex_m
! Purpose : extented-exponent arithmetic (complex)
!
! Copyright 2013-2025 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module ext_complex_m

   ! Uses

   use forum_m, only: RD

   use ext_real_m
   use math_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Derived-type definitions

   type ext_ct
      type(ext_rt) :: re ! Real part
      type(ext_rt) :: im ! Imaginary part
   contains
      procedure       :: op_minus_cx_
      generic, public :: operator(-) => op_minus_cx_
      #:for O, N in zip(('+', '-', '*', '/', '==', '/='), &
                        ('plus', 'minus', 'times', 'divide', 'eq', 'neq'))
         procedure             :: op_${N}$_cx_cx_
         procedure             :: op_${N}$_cx_rx_
         procedure, pass(that) :: op_${N}$_rx_cx_
         procedure             :: op_${N}$_cx_r_
         procedure, pass(that) :: op_${N}$_r_cx_
         procedure             :: op_${N}$_cx_c_
         procedure, pass(that) :: op_${N}$_c_cx_
         generic, public       :: operator(${O}$) => op_${N}$_cx_cx_, op_${N}$_cx_rx_, op_${N}$_rx_cx_, &
            &                                        op_${N}$_cx_r_, op_${N}$_r_cx_, &
            &                                        op_${N}$_cx_c_, op_${N}$_c_cx_
      #:endfor
   end type ext_ct

   ! Parameter definitions

   type(ext_ct), parameter :: ZERO_CT = ext_ct(ZERO_RT, ZERO_RT)
   type(ext_ct), parameter :: ONE_CT = ext_ct(ONE_RT, ZERO_RT)

   real(RD), parameter :: RADIX_RD = REAL(RADIX(1._RD), RD)

   ! Interface blocks

   interface ext_ct
      module procedure ext_ct_r_
      module procedure ext_ct_r_i_
      module procedure ext_ct_c_
      module procedure ext_ct_rx_
      module procedure ext_ct_rx_ix_
   end interface ext_ct

   interface ext_rt
      module procedure ext_rt_cx_
   end interface ext_rt

   interface real
      module procedure real_
   end interface real

   interface cmplx
      module procedure cmplx_
   end interface cmplx

   interface valid
      module procedure valid_
   end interface valid

   interface conjg
      module procedure conjg_
   end interface conjg

   interface product
      module procedure product_
   end interface product

   interface exp
      module procedure exp_
   end interface exp

   interface sqrt
      module procedure sqrt_
   end interface sqrt

   interface abs
      module procedure abs_
   end interface abs

   ! Access specifiers

   public :: ZERO_CT
   public :: ONE_CT
   public :: ext_ct
   public :: ext_rt
   public :: real
   public :: cmplx
   public :: valid
   public :: conjg
   public :: product
   public :: product_ct
   public :: abs
   public :: exp
   public :: sqrt

   ! Default access

   private

contains

   pure elemental function ext_ct_r_(r) result(cx)

      real(RD), intent(in) :: r
      type(ext_ct)         :: cx

      ! Construct the ext_ct from the real r

      cx%re = ext_rt(r)
      cx%im = ZERO_RT

      ! Finish

      return

   end function ext_ct_r_

   !****

   pure elemental function ext_ct_r_i_(r, i) result(cx)

      real(RD), intent(in) :: r
      real(RD), intent(in) :: i
      type(ext_ct)         :: cx

      ! Construct the ext_ct from the real/imaginary pair r, i

      cx%re = ext_rt(r)
      cx%im = ext_rt(i)

      ! Finish

      return

   end function ext_ct_r_i_

   !****

   pure elemental function ext_ct_c_(c) result(cx)

      complex(RD), intent(in) :: c
      type(ext_ct)            :: cx

      ! Construct the ext_ct from the complex c

      cx%re = ext_rt(REAL(c))
      cx%im = ext_rt(AIMAG(c))

      ! Finish

      return

   end function ext_ct_c_

   !****

   pure elemental function ext_ct_rx_(rx) result(cx)

      type(ext_rt), intent(in) :: rx
      type(ext_ct)             :: cx

      ! Construct the ext_ct from the ext_rt rx

      cx%re = rx
      cx%im = ZERO_RT

      ! Finish

      return

   end function ext_ct_rx_

   !****

   pure elemental function ext_ct_rx_ix_(rx, ix) result(cx)

      type(ext_rt), intent(in) :: rx
      type(ext_rt), intent(in) :: ix
      type(ext_ct)             :: cx

      ! Construct the ext_ct from the ext_rt real/imaginary pair rx,
      ! ix

      cx%re = rx
      cx%im = ix

      ! Finish

      return

   end function ext_ct_rx_ix_

   !****

   pure elemental function op_plus_cx_cx_(this, that) result(cx)

      class(ext_ct), intent(in) :: this
      class(ext_ct), intent(in) :: that
      type(ext_ct)              :: cx

      ! Evaluate the plus operator

      cx%re = this%re + that%re
      cx%im = this%im + that%im

      ! Finish

      return

   end function op_plus_cx_cx_

   !****

   pure elemental function op_minus_cx_(this) result(cx)

      class(ext_ct), intent(in) :: this
      type(ext_ct)              :: cx

      ! Evaluate the unary minus operator

      cx%re = -this%re
      cx%im = -this%im

      ! Finish

      return

   end function op_minus_cx_

   !****

   pure elemental function op_minus_cx_cx_(this, that) result(cx)

      class(ext_ct), intent(in) :: this
      class(ext_ct), intent(in) :: that
      type(ext_ct)              :: cx

      ! Evaluate the minus operator

      cx%re = this%re - that%re
      cx%im = this%im - that%im

      ! Finish

      return

   end function op_minus_cx_cx_

   !****

   pure elemental function op_times_cx_cx_(this, that) result(cx)

      class(ext_ct), intent(in) :: this
      class(ext_ct), intent(in) :: that
      type(ext_ct)              :: cx

      ! Evaluate the times operator

      cx%re = this%re*that%re - this%im*that%im
      cx%im = this%re*that%im + this%im*that%re

      ! Finish

      return

   end function op_times_cx_cx_

   !****

   pure elemental function op_divide_cx_cx_(this, that) result(cx)

      class(ext_ct), intent(in) :: this
      class(ext_ct), intent(in) :: that
      type(ext_ct)              :: cx

      type(ext_rt) :: d
      type(ext_rt) :: f

      ! Evaluate the divide operator

      if (abs(that%re) >= abs(that%im)) then
         f = that%im/that%re
         d = that%re + that%im*f
         cx%re = (this%re + this%im*f)/d
         cx%im = (this%im - this%re*f)/d
      else
         f = that%re/that%im
         d = that%re*f + that%im
         cx%re = (this%re*f + this%im)/d
         cx%im = (this%im*f - this%re)/d
      end if

      ! Finish

      return

   end function op_divide_cx_cx_

   !****

   pure elemental function op_eq_cx_cx_(this, that) result(eq)

      class(ext_ct), intent(in) :: this
      class(ext_ct), intent(in) :: that
      logical                   :: eq

      ! Evaluate the equality operator

      eq = this%re == that%re .AND. this%im == that%im

      ! Finish

      return

   end function op_eq_cx_cx_

   !****

   pure elemental function op_neq_cx_cx_(this, that) result(neq)

      class(ext_ct), intent(in) :: this
      class(ext_ct), intent(in) :: that
      logical                   :: neq

      ! Evaluate the inequality operator

      neq = .NOT. this == that

      ! Finish

      return

   end function op_neq_cx_cx_

   !****

   #:for O, N, T in zip(('+', '-', '*', '/', '==', '/='), &
                        ('plus', 'minus', 'times', 'divide', 'eq', 'neq'), &
                        ('type(ext_ct)',)*4+('logical',)*2)

      pure elemental function op_${N}$_cx_rx_(this, that) result(${N}$)

         class(ext_ct), intent(in) :: this
         class(ext_rt), intent(in) :: that
         ${T}$                     :: ${N}$

         ! Evaluate the operator to mixed ext_ct/ext_rt types

         ${N}$ = this ${O}$ ext_ct(that)

         ! Finish

         return

      end function op_${N}$_cx_rx_

      pure elemental function op_${N}$_rx_cx_(this, that) result(${N}$)

         class(ext_rt), intent(in) :: this
         class(ext_ct), intent(in) :: that
         ${T}$                      :: ${N}$

         ! Evaluate the operator to mixed ext_rt/ext_ct types

         ${N}$ = ext_ct(this) ${O}$ that

         ! Finish

         return

      end function op_${N}$_rx_cx_

      pure elemental function op_${N}$_cx_c_(this, that) result(${N}$)

         class(ext_ct), intent(in) :: this
         complex(RD), intent(in)    :: that
         ${T}$                      :: ${N}$

         ! Evaluate the operator to mixed ext_ct/complex types

         ${N}$ = this ${O}$ ext_ct(that)

         ! Finish

         return

      end function op_${N}$_cx_c_

      pure elemental function op_${N}$_c_cx_(this, that) result(${N}$)

         complex(RD), intent(in)    :: this
         class(ext_ct), intent(in) :: that
         ${T}$                      :: ${N}$

         ! Evaluate the operator to mixed complex/ext_ct types

         ${N}$ = ext_ct(this) ${O}$ that

         ! Finish

         return

      end function op_${N}$_c_cx_

      pure elemental function op_${N}$_cx_r_(this, that) result(${N}$)

         class(ext_ct), intent(in) :: this
         real(RD), intent(in)       :: that
         ${T}$                      :: ${N}$

         ! Evaluate the operator to mixed ext_ct/real types

         ${N}$ = this ${O}$ ext_ct(that)

         ! Finish

         return

      end function op_${N}$_cx_r_

      pure elemental function op_${N}$_r_cx_(this, that) result(${N}$)

         real(RD), intent(in)       :: this
         class(ext_ct), intent(in) :: that
         ${T}$                      :: ${N}$

         ! Evaluate the operator to mixed real/ext_ct types

         ${N}$ = ext_ct(this) ${O}$ that

         ! Finish

         return

      end function op_${N}$_r_cx_

   #:endfor

   !****

   pure elemental function ext_rt_cx_(cx) result(rx)

      type(ext_ct), intent(in) :: cx
      type(ext_rt)             :: rx

      ! Construct the ext_rt from the ext_ct

      rx = cx%re

      ! Finish

      return

   end function ext_rt_cx_

   !****

   pure elemental function real_(cx) result(r)

      type(ext_ct), intent(in) :: cx
      real(RD)                 :: r

      ! Convert cx to real

      r = REAL(cmplx(cx))

      ! Finish

      return

   end function real_

   !****

   pure elemental function cmplx_(cx) result(c)

      type(ext_ct), intent(in) :: cx
      complex(RD)              :: c

      ! Convert cx to complex

      c = CMPLX(real(cx%re), real(cx%im), KIND=RD)

      ! Finish

      return

   end function cmplx_

   !****

   pure elemental function valid_(cx)

      type(ext_ct), intent(in) :: cx
      logical                  :: valid_

      ! Determine if cx is valid

      valid_ = valid(cx%re) .AND. valid(cx%im)

      ! Finish

      return

   end function valid_

   !****

   pure elemental function conjg_(cx) result(conjg_cx)

      type(ext_ct), intent(in) :: cx
      type(ext_ct)             :: conjg_cx

      ! Calculate the complex conjugate of cx

      conjg_cx = ext_ct(cx%re, -cx%im)

      ! Finish

      return

   end function conjg_

   !****

   pure function product_(cx) result(prod_cx)

      type(ext_ct), intent(in) :: cx(:)
      type(ext_ct)             :: prod_cx

      integer     :: i

      ! Calculate the product of the elements of cx

      prod_cx = ONE_CT

      do i = 1,SIZE(cx)

         prod_cx = prod_cx*cx(i)

      end do

      ! Finish

      return

   end function product_

   !****

   pure function product_ct(c) result(prod_cx)

      complex(RD), intent(in) :: c(:)
      type(ext_ct)            :: prod_cx

      integer     :: i

      ! Calculate the product of the elements of c

      prod_cx = ONE_CT

      do i = 1,SIZE(c)

         prod_cx = prod_cx*c(i)

      end do

      ! Finish

      return

   end function product_ct

   !****

   pure elemental function abs_(cx) result(abs_cx)

      type(ext_ct), intent(in) :: cx
      type(ext_rt)             :: abs_cx

      type(ext_rt) :: a_re
      type(ext_rt) :: a_im

      ! Calculate the absolute value of cx

      a_re = abs(cx%re)
      a_im = abs(cx%im)

      if (a_re /= 0._RD .OR. a_im /= 0._RD) then

         if (a_re >= a_im) then
            abs_cx = a_re*sqrt(ONE_RT + (cx%im*cx%im)/(cx%re*cx%re))
         else
            abs_cx = a_im*sqrt(ONE_RT + (cx%re*cx%re)/(cx%im*cx%im))
         end if

      else

         abs_cx = ZERO_RT

      end if

      ! Finish

      return

   end function abs_

   !****

   pure elemental function exp_(cx) result(exp_cx)

      type(ext_ct), intent(in) :: cx
      type(ext_ct)             :: exp_cx

      ! Calculate the exponential of cx

      exp_cx = exp(cx%re)*ext_ct(exp((0._RD,1._RD)*real(cx%im)))

      ! Finish

      return

   end function exp_

   !****

   pure elemental function sqrt_(cx) result(sqrt_cx)

      type(ext_ct), intent(in) :: cx
      type(ext_ct)             :: sqrt_cx

      type(ext_rt) :: a_re
      type(ext_rt) :: a_im
      type(ext_rt) :: f
      type(ext_rt) :: w

      ! Calculate the square root of cx

      if (cx%re == ZERO_RT .AND. cx%im == ZERO_RT) then

         sqrt_cx = ZERO_CT

      else

         a_re = abs(cx%re)
         a_im = abs(cx%im)

         if (a_re >= a_im) then

            f = a_im/a_re

            w = sqrt(a_re*0.5_RD*(ONE_RT + sqrt(1._RD + f*f)))

         else

            f = a_re/a_im

            w = sqrt(a_im*0.5_RD*(f + sqrt(1._RD + f*f)))

         end if

         if (cx%re >= ZERO_RT) then

            sqrt_cx%re = w
            sqrt_cx%im = 0.5_RD*cx%im/w

         else

            if (cx%im >= ZERO_RT) then

               sqrt_cx%re = 0.5_RD*a_im/w
               sqrt_cx%im = w

            else

               sqrt_cx%re = 0.5_RD*a_im/w
               sqrt_cx%im = -w

            end if

         end if

      end if

      ! Finish

      return

   end function sqrt_

end module ext_complex_m
