! Program : gyre_map
! Purpose : discriminant mapping code
!
! Copyright 2013-2025 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

program gyre_map

   ! Uses

   use forum_m, only: RD, n_arg, get_arg, hdf5io_t, CREATE_FILE

   use gyre_m, read_out_par_ => read_out_par

   use ISO_FORTRAN_ENV
   #:if defined('OMP')
   use omp_lib
   #:endif

   ! No implicit typing

   implicit none (type, external)

   ! Variables

   character(:), allocatable     :: filename
   integer                       :: unit
   type(model_par_t)             :: ml_p
   type(mode_par_t), allocatable :: md_p(:)
   type(osc_par_t), allocatable  :: os_p(:)
   type(num_par_t), allocatable  :: nm_p(:)
   type(grid_par_t), allocatable :: gr_p(:)
   type(rot_par_t), allocatable  :: rt_p(:)
   type(scan_par_t), allocatable :: sc_p(:)
   character(FILENAME_LEN)       :: map_filename
   class(model_t), pointer       :: ml => null()
   type(osc_par_t)               :: os_p_sel
   type(rot_par_t)               :: rt_p_sel
   type(num_par_t)               :: nm_p_sel
   type(grid_par_t)              :: gr_p_sel
   type(scan_par_t), allocatable :: sc_p_sel(:)
   type(context_t), pointer      :: cx => null()
   real(RD), allocatable         :: omega_re(:)
   real(RD), allocatable         :: omega_im(:)
   real(RD)                      :: omega_min
   real(RD)                      :: omega_max
   type(grid_t)                  :: gr
   class(bvp_ct), allocatable    :: bp
   integer                       :: n_omega_re
   integer                       :: n_omega_im
   complex(RD), allocatable      :: discrim_map_f(:,:)
   integer, allocatable          :: discrim_map_e(:,:)
   integer                       :: i_re
   integer                       :: i_im
   complex(RD)                   :: omega
   type(ext_ct)                  :: discrim
   integer                       :: status
   type(hdf5io_t)                :: hi

   ! Read command-line arguments

   @:ASSERT(n_arg() == 1, 'Syntax: gyre_map <filename>')

   call get_arg(1, filename)

   ! Initialize

   call init_math()

   call set_log_level('${LOG_LEVEL}$')

   if (check_log_level('INFO')) then

      write(OUTPUT_UNIT, 100) form_header('gyre_mpa ['//VERSION//']', '-')
100   format(A)

      if (check_log_level('DEBUG')) then
         write(OUTPUT_UNIT, 110) 'Compiler         :', COMPILER_VERSION()
         write(OUTPUT_UNIT, 110) 'Compiler options :', COMPILER_OPTIONS()
110      format(A,1X,A)
      endif

      #:if defined('OMP')
      write(OUTPUT_UNIT, 120) 'OpenMP Threads   :',  omp_get_max_threads()
120   format(A,1X,I0)
      #:endif

      write(OUTPUT_UNIT, 110) 'Input filename   :', filename

   endif

   ! Process arguments

   open(NEWUNIT=unit, FILE=filename, STATUS='OLD')

   call read_constants(unit)

   call read_model_par(unit, ml_p)
   call read_mode_par(unit, md_p)
   call read_osc_par(unit, os_p)
   call read_rot_par(unit, rt_p)
   call read_num_par(unit, nm_p)
   call read_grid_par(unit, gr_p)
   call read_scan_par(unit, sc_p)
   call read_out_par(unit, map_filename)

   @:ASSERT(SIZE(md_p) == 1, 'Must be exactly one mode parameter')

   ! Initialize the model

   if (check_log_level('INFO')) then
      write(OUTPUT_UNIT, 100) form_header('Model Init', '-')
   endif

   ml => model_t(ml_p)

   ! Allocate the context (will be initialized later on)

   allocate(cx)

   ! Select parameters according to tags

   if (check_log_level('INFO')) then

      write(OUTPUT_UNIT, 100) form_header('Mode Init', '-')

      write(OUTPUT_UNIT, 100) 'Mode parameters'

      write(OUTPUT_UNIT, 130) 'l :', md_p(1)%l
      write(OUTPUT_UNIT, 130) 'm :', md_p(1)%m
130   format(3X,A,1X,I0)

      write(OUTPUT_UNIT, *)

   endif

   call select_par(os_p, md_p(1)%tag, os_p_sel)
   call select_par(rt_p, md_p(1)%tag, rt_p_sel)
   call select_par(nm_p, md_p(1)%tag, nm_p_sel)
   call select_par(gr_p, md_p(1)%tag, gr_p_sel)
   call select_par(sc_p, md_p(1)%tag, sc_p_sel)

   ! Create the scaffold grid

   gr = grid_t(ml, gr_p_sel)

   ! Set up the context

   cx = context_t(ml, gr, md_p(1), os_p_sel, rt_p_sel)

   ! Set up the frequency arrays

   call build_scan(cx, md_p(1), os_p_sel, sc_p_sel, 'REAL', omega_re)
   call build_scan(cx, md_p(1), os_p_sel, sc_p_sel, 'IMAG', omega_im)

   ! Set frequency bounds and perform checks

   if (nm_p_sel%restrict_roots) then
      omega_min = MINVAL(omega_re)
      omega_max = MAXVAL(omega_re)
   else
      omega_min = -HUGE(0._RD)
      omega_max = HUGE(0._RD)
   endif

   call check_scan(cx, gr, omega_re, md_p(1), os_p_sel)

   ! Refine the grid

   call refine_grid(gr, cx, omega_re, gr_p_sel, os_p_sel)

   ! Set up the bvp

   bp = nad_bvp_t(cx, gr, md_p(1), nm_p_sel, os_p_sel)

   ! Map the discriminant

   if (check_log_level('INFO')) then
      write(OUTPUT_UNIT, 100) form_header('Discriminant Mapping', '-')
   endif

   n_omega_re = SIZE(omega_re)
   n_omega_im = SIZE(omega_im)

   allocate(discrim_map_f(n_omega_re,n_omega_im))
   allocate(discrim_map_e(n_omega_re,n_omega_im))

   !$OMP PARALLEL DO FIRSTPRIVATE(bp) PRIVATE(omega, discrim) COLLAPSE(2)
   do i_im = 1, n_omega_im
      do i_re = 1, n_omega_re

         omega = CMPLX(omega_re(i_re), omega_im(i_im), KIND=RD)

         call eval_discrim(bp, state_ct(omega, omega_r=0._RD), discrim)

         discrim_map_f(i_re,i_im) = FRACTION(discrim)
         discrim_map_e(i_re,i_im) = EXPONENT(discrim)

      end do
   end do

   !  Write out the map

   hi = hdf5io_t(map_filename, CREATE_FILE)

   call hi%write_dset('omega_re', omega_re)
   call hi%write_dset('omega_im', omega_im)

   call hi%write_dset('discrim_map_f', discrim_map_f)
   call hi%write_dset('discrim_map_e', discrim_map_e)

   call hi%final()

   ! Clean up

   deallocate(cx)

   deallocate(ml)

   ! Finish

contains

   subroutine read_out_par (unit, map_filename)

      integer, intent(in)       :: unit
      character(*), intent(out) :: map_filename

      namelist /output/ map_filename

      ! Read output parameters

      rewind(unit)

      read(unit, NML=output)

      ! Finish

      return

   end subroutine read_out_par

end program
