! Program  : eval_love
! Purpose  : evaluate static Love numbers
!
! Copyright 2013-2025 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

program eval_love

   ! Uses

   use forum_m, only: RD, hdf5io_t, CREATE_FILE, arg_parser_t, OPT_REQUIRED_ARG

   use gyre_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Variables

   character(:), allocatable :: file_name
   character(:), allocatable :: model_type
   character(:), allocatable :: file_format
   integer, allocatable      :: l

   type(arg_parser_t)            :: arg_parser
   type(model_par_t)             :: ml_p
   type(osc_par_t)               :: os_p
   type(rot_par_t)               :: rt_p
   type(num_par_t)               :: nm_p
   type(grid_par_t)              :: gr_p
   type(mode_par_t)              :: md_p
   class(model_t), pointer       :: ml => null()
   type(context_t), pointer      :: cx
   type(grid_t)                  :: gr
   type(sad_bvp_t)               :: bp
   class(sysmtx_rt), allocatable :: sm
   type(state_rt)                :: st
   real(RD)                      :: A
   real(RD)                      :: B
   real(RD)                      :: w_i(1)
   real(RD)                      :: w_o(1)
   type(wave_t)                  :: wv
   real(RD)                      :: k_l

   ! Read parameters

   model_type = 'EVOL'
   file_format = 'GSM'

   arg_parser = arg_parser_t('eval_love MODEL_FILE', auto_help=.TRUE.)

   call arg_parser%define_option('l', OPT_REQUIRED_ARG, 'l', &
      usage='--l=L', description='harmonic degree')
   call arg_parser%define_option('model-type', OPT_REQUIRED_ARG, &
      usage='--model-type=TYPE', description='model type ( EVOL | POLY | ...)')
   call arg_parser%define_option('file-format', OPT_REQUIRED_ARG, &
      usage='--file-format=FORMAT', description='file format ( GSM | MESA | ... )')

   call arg_parser%parse(arg_proc, opt_proc)

   if (.NOT. ALLOCATED(file_name)) call print_summary()

   if (.NOT. ALLOCATED(l)) then
      @:STOP('--l must be specified')
   end if

   ! Initialize

   call init_math()

   ! Check arguments

   @:ASSERT(ABS(l) >= 0, 'invalid l')

   ! Set up parameters

   ml_p = model_par_t(model_type=model_type, file_format=file_format, file=file_name)

   os_p = osc_par_t()
   rt_p = rot_par_t()
   nm_p = num_par_t()
   gr_p = grid_par_t(w_osc=10._RD, w_exp=2._RD, w_ctr=10._RD)
   md_p = mode_par_t(l=l)

   ! Initialize the model

   ml => model_t(ml_p)

   ! Set up the scaffold grid

   gr = grid_t(ml, gr_p)

   ! Set up the context

   allocate(cx)

   cx = context_t(ml, gr, md_p, os_p, rt_p)

   ! Refine the grid (using omega=3 as representative of the f-mode
   ! frequency)

   call refine_grid(gr, cx, [3._RD], gr_p, os_p)

   ! Solve for the tidal response

   bp = sad_bvp_t(cx, gr, md_p, nm_p, os_p)

   allocate(sm, SOURCE=sysmtx_rt(bp, nm_p))

   A = 1._RD

   w_i = 0._RD
   w_o = (2*l+1)*A

   st = state_rt(0._RD)

   wv = wave_t(bp, sm, st, w_i, w_o, 0)

   ! Evaluate the Love number

   B = wv%eul_Phi(wv%n) - A

   k_l = B/A

   print *, k_l

   ! Finish

contains

   subroutine arg_proc(a, value)

      integer, intent(in)      :: a
      character(*), intent(in) :: value

      select case(a)
      case(1)
         file_name = value
      case default
         call print_summary()
      end select

   end subroutine arg_proc

   !****

   subroutine opt_proc(name, value)

      character(*), intent(in) :: name
      character(*), intent(in) :: value

      integer :: stat

      stat = STAT_OK

      select case(name)
      case('l')
         call parse_value(value, l)
      case('model-type')
         model_type = value
      case('file-format')
         file_format = value
      case('help')
         call print_summary()
      case default
         @:ABORT('invalid option name')
      end select

      if (stat /= STAT_OK) then
         @:STOP('invalid --'//name)
      end if

   end subroutine opt_proc

   !****

   subroutine print_summary()

      call arg_parser%print_summary()
      @:STOP()

   end subroutine print_summary

end program eval_love
