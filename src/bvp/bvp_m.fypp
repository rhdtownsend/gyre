! Module  : bvp_m
! Purpose : parametric boundary value problems
!
! Copyright 2013-2025 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module bvp_m

   ! Uses

   use forum_m, only: RD

   use bound_m
   use diff_element_m
   use ext_m
   use num_par_m
   use state_m
   use status_m
   use sysmtx_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   #:for T, S in zip(DTYPE_BASE_TYPES, DTYPE_SUFFIXES)

      ! Derived-type definitions

      type :: bvp_${S}$
         private
         class(diff_element_${S}$), allocatable :: de(:)
         class(bound_${S}$), allocatable        :: bd_i
         class(bound_${S}$), allocatable        :: bd_o
         integer, public                        :: n
         integer, public                        :: n_e
         integer, public                        :: n_i
         integer, public                        :: n_o
      contains
         private
         procedure, public :: eval_det => eval_det_${S}$_
         procedure, public :: solve_hom => solve_hom_${S}$_
         procedure, public :: solve_inhom => solve_inhom_${S}$_
      end type bvp_${S}$

      ! Interfaces

      interface bvp_${S}$
         module procedure bvp_${S}$_
      end interface bvp_${S}$

      ! Access specifiers

      public :: bvp_${S}$

   #:endfor

   ! Default access

   private

contains

   #:for T, S in zip(DTYPE_BASE_TYPES, DTYPE_SUFFIXES)

      function bvp_${S}$_(bd_i, bd_o, de, nm_p) result(bp)

         class(bound_${S}$), intent(in)        :: bd_i
         class(bound_${S}$), intent(in)        :: bd_o
         class(diff_element_${S}$), intent(in) :: de(:)
         type(num_par_t), intent(in)           :: nm_p
         type(bvp_${S}$)                       :: bp

         integer :: n
         integer :: n_e
         integer :: n_i
         integer :: n_o

         ! Perform basic validations

         n = SIZE(de) + 1

         @:CHECK_BOUNDS(bd_i%n_e, bd_o%n_e)

         n_e = bd_i%n_e

         n_i = bd_i%n_b
         n_o = bd_o%n_b

         @:CHECK_BOUNDS(n_i+n_o, n_e)

!         @:ASSERT_DEBUG(ALL(de%df%n_e == n_e), 'dimension mismatch')

         ! Construct the bvp type

         allocate(bp%de, SOURCE=de)

         bp%bd_i = bd_i
         bp%bd_o = bd_o

         bp%n = n
         bp%n_e = n_e
         bp%n_i = n_i
         bp%n_o = n_o

         ! Finish

         return

      end function bvp_${S}$_

      !****

      subroutine eval_det_${S}$_(this, sm, st, det)

         class(bvp_${S}$), intent(in)       :: this
         class(sysmtx_${S}$), intent(inout) :: sm
         class(state_${S}$), intent(in)     :: st
         type(ext_${S}$), intent(out)       :: det

         @:ASSERT_DEBUG(sm%n+1 == this%n, 'dimension mismatch')
         @:ASSERT_DEBUG(sm%n_e == this%n_e, 'dimension mismatch')
         @:ASSERT_DEBUG(sm%n_i == this%n_i, 'dimension mismatch')
         @:ASSERT_DEBUG(sm%n_o == this%n_o, 'dimension mismatch')

         ! Evaluate the determinant of the sysmtx

         call sm%eval_det(st, this%bd_i, this%bd_o, this%de, det)

         ! Finish

         return

      end subroutine eval_det_${S}$_

      !****

      subroutine solve_hom_${S}$_(this, sm, st, y)

         class(bvp_${S}$), intent(in)       :: this
         class(sysmtx_${S}$), intent(inout) :: sm
         class(state_${S}$), intent(in)     :: st
         ${T}$, intent(out)                 :: y(:,:)

         ${T}$ :: u(this%n_e*this%n)

         @:ASSERT_DEBUG(sm%n+1 == this%n, 'dimension mismatch')
         @:ASSERT_DEBUG(sm%n_e == this%n_e, 'dimension mismatch')
         @:ASSERT_DEBUG(sm%n_i == this%n_i, 'dimension mismatch')
         @:ASSERT_DEBUG(sm%n_o == this%n_o, 'dimension mismatch')

         @:CHECK_BOUNDS(SIZE(y, 1), this%n_e)
         @:CHECK_BOUNDS(SIZE(y, 2), this%n)

         ! Evaluate the solution vector y of the homogeneous system

         call sm%solve_hom(st, this%bd_i, this%bd_o, this%de, u)

         y = RESHAPE(u, SHAPE(y))

         ! Finish

         return

      end subroutine solve_hom_${S}$_

      !****

      subroutine solve_inhom_${S}$_(this, sm, st, z_i, z_o, y)

         class(bvp_${S}$), intent(in)       :: this
         class(sysmtx_${S}$), intent(inout) :: sm
         class(state_${S}$), intent(in)     :: st
         ${T}$, intent(in)                  :: z_i(:)
         ${T}$, intent(in)                  :: z_o(:)
         ${T}$, intent(out)                 :: y(:,:)

         ${T}$ :: u(this%n_e*this%n)

         @:ASSERT_DEBUG(sm%n+1 == this%n, 'dimension mismatch')
         @:ASSERT_DEBUG(sm%n_e == this%n_e, 'dimension mismatch')
         @:ASSERT_DEBUG(sm%n_i == this%n_i, 'dimension mismatch')
         @:ASSERT_DEBUG(sm%n_o == this%n_o, 'dimension mismatch')

         @:CHECK_BOUNDS(SIZE(z_i), this%n_i)
         @:CHECK_BOUNDS(SIZE(z_o), this%n_o)

         @:CHECK_BOUNDS(SIZE(y, 1), this%n_e)
         @:CHECK_BOUNDS(SIZE(y, 2), this%n)

         ! Evaluate the solution vector y of the inhomogeneous system

         call sm%solve_inhom(st, this%bd_i, this%bd_o, this%de, [z_i,z_o], u)

         y = RESHAPE(u, SHAPE(y))

         ! Finish

         return

      end subroutine solve_inhom_${S}$_

   #:endfor

end module bvp_m
