! Module  : colloc_gl6_diff_m
! Purpose : difference equations (6th-order Gauss-Legendre collocation)
!
! Copyright 2013-2025 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module colloc_gl6_diff_m

   ! Uses

   use forum_m, only: RD

   use blas_lapack_m
   use diff_m
   use eqns_m
   use ext_m
   use linalg_m
   use math_m
   use point_m
   use state_m

   use f95_lapack

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Parameter definitions

   #:for S in DTYPE_SUFFIXES

      ! Derived-type definitions

      type, extends(diff_${S}$) :: colloc_gl6_diff_${S}$
         private
         class(eqns_${S}$), allocatable   :: eq(:)
         real(RD)                         :: dx
         logical                          :: reverse
      contains
         private
         procedure, public :: build => build_${S}$_
      end type colloc_gl6_diff_${S}$

      ! Interfaces

      interface colloc_gl6_diff_${S}$
         module procedure colloc_gl6_diff_${S}$_
      end interface colloc_gl6_diff_${S}$

      ! Access specifiers

      public :: colloc_gl6_diff_${S}$

   #:endfor

   ! Default access

   private

contains

   #:for T, S in zip(DTYPE_BASE_TYPES, DTYPE_SUFFIXES)

      function colloc_gl6_diff_${S}$_(eqns_factory, pt_a, pt_b) result(df)

         interface
            subroutine eqns_factory(pt, eq)
               use point_m
               use eqns_m
               implicit none (type, external)
               type(point_t), intent(in)                   :: pt(:)
               class(eqns_${S}$), allocatable, intent(out) :: eq(:)
            end subroutine eqns_factory
         end interface
         type(point_t), intent(in)   :: pt_a
         type(point_t), intent(in)   :: pt_b
         type(colloc_gl6_diff_${S}$) :: df

         real(RD), parameter :: C(3) = [ &
            0.5_RD-sqrt(15._RD)/10._RD, &
            0.5_RD, &
            0.5_RD+sqrt(15._RD)/10._RD]

         type(point_t) :: pt(3)

         @:ASSERT_DEBUG(pt_a%s == pt_b%s, 'segment mismatch')

         ! Construct the colloc_gl6_diff type

         pt%s = pt_a%s

         df%dx = pt_b%x - pt_a%x
         pt%x = pt_a%x + C*df%dx

         call eqns_factory(pt, df%eq)

         df%n_e = df%eq(1)%n_e

         ! Finish

         return

      end function colloc_gl6_diff_${S}$_

      !****

      subroutine build_${S}$_(this, st, E_l, E_r, scl)

         class(colloc_gl6_diff_${S}$), intent(in) :: this
         class(state_${S}$), intent(in)           :: st
         ${T}$, intent(out)                       :: E_l(:,:)
         ${T}$, intent(out)                       :: E_r(:,:)
         type(ext_${S}$), intent(out)             :: scl

         real(RD), parameter :: D_12 = -sqrt(15._RD)/15._RD
         real(RD), parameter :: D_13 = -sqrt(15._RD)/30._RD
         real(RD), parameter :: D_21 = sqrt(15._RD)/24._RD
         real(RD), parameter :: D_23 = -sqrt(15._RD)/24._RD
         real(RD), parameter :: D_31 = sqrt(15._RD)/30._RD
         real(RD), parameter :: D_32 = sqrt(15._RD)/15._RD

         real(RD), parameter :: B_1 = 5._RD/18._RD
         real(RD), parameter :: B_2 = 4._RD/9._RD
         real(RD), parameter :: B_3 = 5._RD/18._RD

         ${T}$  :: A_1(this%n_e,this%n_e)
         ${T}$  :: A_2(this%n_e,this%n_e)
         ${T}$  :: A_3(this%n_e,this%n_e)
         ${T}$  :: A_21(this%n_e,this%n_e)
         ${T}$  :: A_31(this%n_e,this%n_e)
         ${T}$  :: I(this%n_e,this%n_e)
         ${T}$  :: U_12(this%n_e,this%n_e)
         ${T}$  :: U_13(this%n_e,this%n_e)
         ${T}$  :: U_23(this%n_e,this%n_e)
         ${T}$  :: M_2(this%n_e,this%n_e)
         ${T}$  :: S_3(this%n_e,this%n_e)
         ${T}$  :: M_3(this%n_e,this%n_e)
         ${T}$  :: R_1(this%n_e,this%n_e)
         ${T}$  :: R_2(this%n_e,this%n_e)
         ${T}$  :: R_3(this%n_e,this%n_e)
         integer :: ipiv(this%n_e)
         ${T}$   :: K_1(this%n_e,this%n_e)
         ${T}$   :: K_2(this%n_e,this%n_e)
         ${T}$   :: K_3(this%n_e,this%n_e)
         ${T}$   :: J(this%n_e,this%n_e)

         ! Build the difference equations

         ! Algorithm note: this is Gauss-Legendre collocation with 3
         ! intermediate points. The implementation follows the
         ! approach in the StORM code

         call this%eq(1)%eval_A(st, A_1)
         A_1 = this%dx*A_1

         call this%eq(2)%eval_A(st, A_2)
         A_2 = this%dx*A_2

         call this%eq(3)%eval_A(st, A_3)
         A_3 = this%dx*A_3

         A_21 = MATMUL(A_2, A_1)
         A_31 = MATMUL(A_3, A_1)

         I = identity_matrix(this%n_e)

         ! First block row

         U_12 = D_12*A_1
         U_13 = D_13*A_1
         R_1 = A_1

         ! Second block row

         M_2 = I - (D_21*D_12)*A_21
         U_23 = D_12*A_2 - D_21*D_13*A_21
         R_2 = A_2 - D_21*A_21

         call LA_GETRF(M_2, ipiv)
         call LA_GETRS(M_2, ipiv, U_23)
         call LA_GETRS(M_2, ipiv, R_2)

         ! Third block row

         S_3 = D_32*A_3 - D_31*D_12*A_31

         M_3 = I - D_31*D_13*A_31 - MATMUL(S_3, U_23)
         R_3 = A_3 - d_31*A_31 - MATMUL(S_3, R_2)

         call LA_GESV(M_3, R_3)

         call LA_GETRS(M_3, ipiv, R_3)

         ! Intermediate matrices

         K_3 = R_3

         K_2 = R_2 - MATMUL(U_23, K_3)

         K_1 = R_1 - MATMUL(U_12, K_2) - MATMUL(U_13, K_3)

         ! Jump matrix

         J = B_1*K_1 + B_2*K_2 + B_3*K_3

         ! Assemble the difference equations

         E_l = J + I
         E_r = J - I

         scl = ONE_${S}$

         ! Finish

         return

      end subroutine build_${S}$_

   #:endfor

end module colloc_gl6_diff_m
