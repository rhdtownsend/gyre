! Module  : nad_factory_m
! Purpose : factory methods for nonadiabatic routines
!
! Copyright 2013-2025 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module nad_factory_m

   ! Uses

   use forum_m, only: RD

   use bound_m
   use context_m
   use eqns_m
   use osc_par_m
   use point_m
   use trans_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Interfaces

   interface nad_eqns_t
      module procedure nad_eqns_t_0_
      module procedure nad_eqns_t_1_
   end interface nad_eqns_t

   interface nad_trans_t
      module procedure nad_trans_t_0_
      module procedure nad_trans_t_1_
   end interface nad_trans_t

   ! Access specifiers

   public :: nad_eqns_t
   public :: nad_eqns_t_0_
   public :: nad_eqns_t_1_
   public :: nad_trans_t
   public :: nad_trans_t_0_
   public :: nad_trans_t_1_
   public :: nad_ibound_t
   public :: nad_obound_t

   ! Default access

   private

contains

   #:for R in (0, 1)

      function nad_eqns_t_${R}$_(cx, pt, os_p) result(eq)

         use gyre_nad_eqns_m
         use dziem_nad_eqns_m
         use jcd_nad_eqns_m
         use rjcd_nad_eqns_m
         use mix_nad_eqns_m
         use lagp_nad_eqns_m

         type(context_t), pointer, intent(in) :: cx
         type(point_t), intent(in)            :: pt${ARRAY_SPEC(R)}$
         type(osc_par_t), intent(in)          :: os_p
         class(eqns_ct), allocatable          :: eq${ARRAY_SPEC(R)}$

         ! Construct the nad_eqns type

         select case(os_p%variables_set)
         case('GYRE')
            eq = gyre_nad_eqns_t(cx, pt, os_p)
         case('DZIEM')
            eq = dziem_nad_eqns_t(cx, pt, os_p)
         case('JCD')
            if (cx%l == 0) then
               eq = rjcd_nad_eqns_t(cx, pt, os_p)
            else
               eq = jcd_nad_eqns_t(cx, pt, os_p)
            end if
         case('MIX')
            eq = mix_nad_eqns_t(cx, pt, os_p)
         case('LAGP')
            eq = lagp_nad_eqns_t(cx, pt, os_p)
         case default
            @:ABORT('invalid variables_set')
         end select

         ! Finish

         return

      end function nad_eqns_t_${R}$_

      !****

      function nad_trans_t_${R}$_(cx, pt, os_p) result(tr)

         use gyre_nad_trans_m
         use dziem_nad_trans_m
         use jcd_nad_trans_m
         use rjcd_nad_trans_m
         use mix_nad_trans_m
         use lagp_nad_trans_m

         type(context_t), pointer, intent(in) :: cx
         type(point_t), intent(in)            :: pt${ARRAY_SPEC(R)}$
         type(osc_par_t), intent(in)          :: os_p
         class(trans_ct), allocatable         :: tr${ARRAY_SPEC(R)}$

         ! Construct the nad_trans type

         select case(os_p%variables_set)
         case('GYRE')
            tr = gyre_nad_trans_t(cx, pt)
         case('DZIEM')
            tr = dziem_nad_trans_t(cx, pt)
         case('JCD')
            if (cx%l == 0) then
               tr = rjcd_nad_trans_t(cx, pt)
            else
               tr = jcd_nad_trans_t(cx, pt)
            end if
         case('MIX')
            tr = mix_nad_trans_t(cx, pt)
         case('LAGP')
            tr = lagp_nad_trans_t(cx, pt)
         case default
            @:ABORT('invalid variables_set')
         end select

         ! Finish

         return

      end function nad_trans_t_${R}$_

   #:endfor

   !****

   function nad_ibound_t(cx, os_p) result(bd)

      use gyre_nad_ibound_m
      use dziem_nad_ibound_m
      use jcd_nad_ibound_m
      use rjcd_nad_ibound_m
      use mix_nad_ibound_m
      use lagp_nad_ibound_m

      type(context_t), pointer, intent(in) :: cx
      type(osc_par_t), intent(in)          :: os_p
      class(bound_ct), allocatable         :: bd

      ! Construct the nad_ibound type

      select case(os_p%variables_set)
      case('GYRE')
         bd = gyre_nad_ibound_t(cx, os_p)
      case('DZIEM')
         bd = dziem_nad_ibound_t(cx, os_p)
      case('JCD')
         if (cx%l == 0) then
            bd = rjcd_nad_ibound_t(cx, os_p)
         else
            bd = jcd_nad_ibound_t(cx, os_p)
         end if
      case('MIX')
         bd = mix_nad_ibound_t(cx, os_p)
      case('LAGP')
         bd = lagp_nad_ibound_t(cx, os_p)
      case default
         @:ABORT('invalid variables_set')
      end select

      ! Finish

      return

   end function nad_ibound_t

   !****

   function nad_obound_t(cx, os_p) result(bd)

      use gyre_nad_obound_m
      use dziem_nad_obound_m
      use jcd_nad_obound_m
      use rjcd_nad_obound_m
      use mix_nad_obound_m
      use lagp_nad_obound_m

      type(context_t), pointer, intent(in) :: cx
      type(osc_par_t), intent(in)          :: os_p
      class(bound_ct), allocatable         :: bd

      ! Construct the nad_obound type

      select case(os_p%variables_set)
      case('GYRE')
         bd = gyre_nad_obound_t(cx, os_p)
      case('DZIEM')
         bd = dziem_nad_obound_t(cx, os_p)
      case('JCD')
         if (cx%l == 0) then
            bd = rjcd_nad_obound_t(cx, os_p)
         else
            bd = jcd_nad_obound_t(cx, os_p)
         end if
      case('MIX')
         bd = mix_nad_obound_t(cx, os_p)
      case('LAGP')
         bd = lagp_nad_obound_t(cx, os_p)
      case default
         @:ABORT('invalid variables_set')
      end select

      ! Finish

      return

   end function nad_obound_t

end module nad_factory_m
