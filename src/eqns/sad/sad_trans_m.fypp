! Module  : rsd_trans_m
! Purpose : static adiabatic variables transformations
!
! Copyright 2013-2025 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

#:set P = os.path.basename(_FILE_).split('_')[0]

module ${P}$_sad_trans_m

   ! Uses

   use forum_m, only: RD

   use context_m
   use model_m
   use model_util_m
   use point_m
   use state_m
   use trans_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Derived-type definitions

   type, extends(trans_rt) :: ${P}$_sad_trans_t
      private
      type(context_t), pointer :: cx => null()
   contains
      private
      procedure, public :: transform
   end type ${P}$_sad_trans_t

   ! Interfaces

   interface ${P}$_sad_trans_t
      module procedure ${P}$_sad_trans_t_0_
      module procedure ${P}$_sad_trans_t_1_
   end interface ${P}$_sad_trans_t

   ! Access specifiers

   public :: ${P}$_sad_trans_t

   ! Default access

   private

contains

   function ${P}$_sad_trans_t_0_(cx, pt) result(tr)

      type(context_t), pointer, intent(in) :: cx
      type(point_t), intent(in)            :: pt
      type(${P}$_sad_trans_t)              :: tr

      class(model_t), pointer :: ml

      ! Construct the ${P}$_sad_trans type

      tr%cx => cx

      ! Store structure coefficients

      ml => cx%model()

      call check_model(ml, [I_V_2,I_U,I_C_1,I_OMEGA_ROT])

      ! Other initializations

      tr%n_e = 2

      ! Finish

      return

   end function ${P}$_sad_trans_t_0_

   !****

   function ${P}$_sad_trans_t_1_(cx, pt) result(tr)

      type(context_t), pointer, intent(in) :: cx
      type(point_t), intent(in)            :: pt(:)
      type(${P}$_sad_trans_t)              :: tr(SIZE(pt))

      integer :: j

      ! Construct the array of ${P}$_sad_trans types

      do j = 1, SIZE(pt)
         tr(j) = ${P}$_sad_trans_t(cx, pt(j))
      end do

      ! Finish

      return

   end function ${P}$_sad_trans_t_1_

   !****

   subroutine transform(this, st, y)

      class(${P}$_sad_trans_t), intent(in) :: this
      class(state_rt), intent(in)          :: st
      real(RD), intent(inout)              :: y(:)

      real(RD) :: R(this%n_e,this%n_e)

      @:CHECK_BOUNDS(SIZE(y), this%n_e)

      ! Transform the variables to canonical form

      ! Set up the transformation matrix

      #:include 'R.inc'

      ! Apply it

      y = MATMUL(R, y)

      ! Finish

      return

   end subroutine transform

end module ${P}$_sad_trans_m
