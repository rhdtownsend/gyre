! Module  : ad_trans_m
! Purpose : adiabatic variables/equations transformations
!
! Copyright 2013-2025 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module ad_trans_m

   ! Uses

   use forum_m, only: RD

   use context_m
   use model_m
   use model_util_m
   use mode_par_m
   use osc_par_m
   use point_m
   use state_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Parameter definitions

   integer, parameter :: SET = 0
   integer, parameter :: DZIEM_SET = 1
   integer, parameter :: JCD_SET = 2
   integer, parameter :: MIX_SET = 3
   integer, parameter :: LAGP_SET = 4

   ! Derived-type definitions

   type :: ad_trans_t
      private
      type(context_t), pointer :: cx => null()
      type(point_t)            :: pt
      real(RD)                 :: x
      real(RD)                 :: V_2
      real(RD)                 :: dV_2
      real(RD)                 :: U
      real(RD)                 :: dU
      real(RD)                 :: c_1
      real(RD)                 :: dc_1
      real(RD)                 :: Omega_rot
      real(RD)                 :: lambda
      integer                  :: set
      integer                  :: n_e
   contains
      private
      procedure, public :: trans_eqns
      procedure, public :: trans_cond
      procedure, public :: trans_vars
      procedure         :: G_
      procedure         :: G_dziem_
      procedure         :: G_jcd_
      procedure         :: G_mix_
      procedure         :: G_lagp_
      procedure         :: H_
      procedure         :: H_dziem_
      procedure         :: H_jcd_
      procedure         :: H_mix_
      procedure         :: H_lagp_
      procedure         :: dH_
      procedure         :: dH_jcd_
      procedure         :: dH_mix_
      procedure         :: dH_lagp_
   end type ad_trans_t

   ! Interfaces

   interface ad_trans_t
      module procedure ad_trans_t_
   end interface ad_trans_t

   ! Access specifiers

   public :: ad_trans_t

   ! Default access

   private

contains

   function ad_trans_t_(cx, pt, md_p, os_p) result(tr)

      type(context_t), pointer, intent(in) :: cx
      type(point_t), intent(in)            :: pt
      type(mode_par_t), intent(in)         :: md_p
      type(osc_par_t), intent(in)          :: os_p
      type(ad_trans_t)                     :: tr

      class(model_t), pointer :: ml

      ! Construct the ad_trans type

      select case (os_p%variables_set)
      case ('GYRE')
         tr%set = SET
      case ('DZIEM')
         tr%set = DZIEM_SET
      case ('JCD')
         tr%set = JCD_SET
      case ('MIX')
         tr%set = MIX_SET
      case ('LAGP')
         tr%set = LAGP_SET
      case default
         @:ABORT('invalid variables_set')
      end select

      tr%cx => cx

      tr%pt = pt

      ! Store structure coefficients

      ml => cx%model()

      call check_model(ml, [I_V_2,I_U,I_C_1,I_OMEGA_ROT])

      if (ml%is_vacuum(pt)) then
         @:ASSERT(tr%set /= LAGP_SET, 'LAGP invalid at vacuum point')
         tr%V_2 = HUGE(0._RD)
         tr%dV_2 = HUGE(0._RD)
         tr%dU = -HUGE(0._RD)
      else
         tr%V_2 = ml%coeff(I_V_2, pt)
         tr%dV_2 = ml%dcoeff(I_V_2, pt)
         tr%dU = ml%dcoeff(I_U, pt)
      endif

      tr%U = ml%coeff(I_U, pt)
      tr%c_1 = ml%coeff(I_C_1, pt)
      tr%dc_1 = ml%dcoeff(I_C_1, pt)

      tr%Omega_rot = cx%Omega_rot(pt)

      if (cx%angular_cache) then
         tr%lambda = cx%lambda(tr%Omega_rot, state_rt(0._RD))
      end if

      ! Other initializations

      tr%x = pt%x

      tr%n_e = 4

      ! Finish

      return

   end function ad_trans_t_

   !****

   subroutine trans_eqns (this, A, st, from)

      class(ad_trans_t), intent(in) :: this
      real(RD), intent(inout)       :: A(:,:)
      class(state_rt), intent(in)   :: st
      logical, intent(in), optional :: from

      logical               :: from_
      real(RD), allocatable :: G(:,:)
      real(RD), allocatable :: H(:,:)
      real(RD), allocatable :: dH(:,:)

      @:CHECK_BOUNDS(SIZE(A, 1), this%n_e)
      @:CHECK_BOUNDS(SIZE(A, 2), this%n_e)

      if (PRESENT(from)) then
         from_ = from
      else
         from_ = .TRUE.
      endif

      ! Transform equations to/from GYRE's canonical form

      if (from_) then

         ! Convert from

         if (this%set /= SET) then
            G = this%G_(st)
            H = this%H_(st)
            dH = this%dH_(st)
            A = MATMUL(G, MATMUL(A, H) - dH)
         endif

      else

         ! Convert to

         @:ABORT('not currently supported')

      end if

      ! Finish

      return

   end subroutine trans_eqns

   !****

   subroutine trans_cond (this, C, st, from)

      class(ad_trans_t), intent(in) :: this
      real(RD), intent(inout)       :: C(:,:)
      class(state_rt), intent(in)   :: st
      logical, intent(in), optional :: from

      logical               :: from_
      real(RD), allocatable :: G(:,:)
      real(RD), allocatable :: H(:,:)

      @:CHECK_BOUNDS(SIZE(C, 2), this%n_e)

      if (PRESENT(from)) then
         from_ = from
      else
         from_ = .TRUE.
      endif

      ! Transform boundary/match conditions to/from GYRE's canonical form

      if (from_) then

         ! Convert from

         if (this%set /= SET) then
            H = this%H_(st)
            C = MATMUL(C, H)
         endif

      else

         ! Convert to

         if (this%set /= SET) then
            G = this%G_(st)
            C = MATMUL(C, G)
         endif

      end if

      ! Finish

      return

   end subroutine trans_cond

   !****

   subroutine trans_vars (this, y, st, from)

      class(ad_trans_t), intent(in) :: this
      real(RD), intent(inout)       :: y(:)
      class(state_rt), intent(in)   :: st
      logical, intent(in), optional :: from

      logical               :: from_
      real(RD), allocatable :: G(:,:)
      real(RD), allocatable :: H(:,:)

      @:CHECK_BOUNDS(SIZE(y), this%n_e)

      if (PRESENT(from)) then
         from_ = from
      else
         from_ = .TRUE.
      endif

      ! Convert variables to/from GYRE's canonical form

      if (from_) then

         ! Convert from

         if (this%set /= SET) then
            G = this%G_(st)
            y = MATMUL(G, y)
         endif

      else

         ! Convert to

         if (this%set /= SET) then
            H = this%H_(st)
            y = MATMUL(H, y)
         endif

      end if

      ! Finish

      return

   end subroutine trans_vars

   !****

   function G_(this, st) result(G)

      class(ad_trans_t), intent(in) :: this
      class(state_rt), intent(in)   :: st
      real(RD)                      :: G(4,4)

      ! Evaluate the transformation matrix to convert variables from
      ! the canonical form

      select case (this%set)
      case (DZIEM_SET)
         G = this%G_dziem_(st)
      case (JCD_SET)
         G = this%G_jcd_(st)
      case (MIX_SET)
         G = this%G_mix_(st)
      case (LAGP_SET)
         G = this%G_lagp_(st)
      case default
         @:ABORT('invalid set')
      end select

      ! Finish

      return

   end function G_

   !****

   function G_dziem_(this, st) result(G)

      class(ad_trans_t), intent(in) :: this
      class(state_rt), intent(in)   :: st
      real(RD)                      :: G(this%n_e,this%n_e)

      ! Evaluate the transformation matrix to convert DZIEM variables
      ! from GYRE's canonical form

      ! Set up the matrix

      G(1,1) = 1._RD
      G(1,2) = 0._RD
      G(1,3) = 0._RD
      G(1,4) = 0._RD

      G(2,1) = 0._RD
      G(2,2) = 1._RD
      G(2,3) = 1._RD
      G(2,4) = 0._RD

      G(3,1) = 0._RD
      G(3,2) = 0._RD
      G(3,3) = 1._RD
      G(3,4) = 0._RD

      G(4,1) = 0._RD
      G(4,2) = 0._RD
      G(4,3) = 0._RD
      G(4,4) = 1._RD

      ! Finish

      return

   end function G_dziem_

   !****

   function G_jcd_(this, st) result(G)

      class(ad_trans_t), intent(in) :: this
      class(state_rt), intent(in)   :: st
      real(RD)                      :: G(this%n_e,this%n_e)

      real(RD) :: omega_c
      real(RD) :: lambda

      ! Evaluate the transformation matrix to convert JCD variables
      ! from GYRE's canonical form

      associate( &
         omega => st%omega, &
         U => this%U, &
         c_1 => this%c_1, &
         Omega_rot => this%omega_rot, &
         l => this%cx%l, &
         m => this%cx%m, &
         angular_cache => this%cx%angular_cache)
         
         omega_c = omega - m*Omega_rot

         if (angular_cache) then
            lambda = this%lambda
         else
            lambda = this%cx%lambda(Omega_rot, st)
         end if

         ! Set up the matrix

         if (l /= 0) then

            G(1,1) = 1._RD
            G(1,2) = 0._RD
            G(1,3) = 0._RD
            G(1,4) = 0._RD

            G(2,1) = 0._RD
            G(2,2) = lambda/(c_1*omega_c**2)
            G(2,3) = lambda/(c_1*omega_c**2)
            G(2,4) = 0._RD

            G(3,1) = 0._RD
            G(3,2) = 0._RD
            G(3,3) = -1._RD
            G(3,4) = 0._RD

            G(4,1) = 0._RD
            G(4,2) = 0._RD
            G(4,3) = -(1._RD - U)
            G(4,4) = -1._RD

         else

            G(1,1) = 1._RD
            G(1,2) = 0._RD
            G(1,3) = 0._RD
            G(1,4) = 0._RD

            G(2,1) = 0._RD
            G(2,2) = 1._RD/(c_1*omega_c**2)
            G(2,3) = 1._RD/(c_1*omega_c**2)
            G(2,4) = 0._RD

            G(3,1) = 0._RD
            G(3,2) = 0._RD
            G(3,3) = -1._RD
            G(3,4) = 0._RD

            G(4,1) = 0._RD
            G(4,2) = 0._RD
            G(4,3) = -(1._RD - U)
            G(4,4) = -1._RD

         endif

      end associate

      ! Finish

      return

   end function G_jcd_

   !****

   function G_mix_(this, st) result(G)

      class(ad_trans_t), intent(in) :: this
      class(state_rt), intent(in)   :: st
      real(RD)                      :: G(this%n_e,this%n_e)

      ! Evaluate the transformation matrix to convert MIX variables
      ! from GYRE's canonical form

      associate( &
         U => this%U)

         ! Set up the matrix

         G(1,1) = 1._RD
         G(1,2) = 0._RD
         G(1,3) = 0._RD
         G(1,4) = 0._RD

         G(2,1) = 0._RD
         G(2,2) = 1._RD
         G(2,3) = 0._RD
         G(2,4) = 0._RD

         G(3,1) = 0._RD
         G(3,2) = 0._RD
         G(3,3) = -1._RD
         G(3,4) = 0._RD

         G(4,1) = 0._RD
         G(4,2) = 0._RD
         G(4,3) = -(1._RD - U)
         G(4,4) = -1._RD

      end associate

      ! Finish

      return

   end function G_mix_

   !****

   function G_lagp_(this, st) result(G)

      class(ad_trans_t), intent(in) :: this
      class(state_rt), intent(in)   :: st
      real(RD)                      :: G(this%n_e,this%n_e)

      ! Evaluate the transformation matrix to convert LAGP variables
      ! from GYRE's canonical form

      associate( &
         V_2 => this%V_2)

         ! Set up the matrix

         G(1,1) = 1._RD
         G(1,2) = 0._RD
         G(1,3) = 0._RD
         G(1,4) = 0._RD

         G(2,1) = -V_2
         G(2,2) = V_2
         G(2,3) = 0._RD
         G(2,4) = 0._RD

         G(3,1) = 0._RD
         G(3,2) = 0._RD
         G(3,3) = 1._RD
         G(3,4) = 0._RD

         G(4,1) = 0._RD
         G(4,2) = 0._RD
         G(4,3) = 0._RD
         G(4,4) = 1._RD

      end associate

      ! Finish

      return

   end function G_lagp_

   !****

   function H_(this, st) result(H)

      class(ad_trans_t), intent(in) :: this
      class(state_rt), intent(in)   :: st
      real(RD)                      :: H(4,4)

      ! Evaluate the transformation matrix to convert variables to
      ! canonical form

      select case (this%set)
      case (DZIEM_SET)
         H = this%H_dziem_(st)
      case (JCD_SET)
         H = this%H_jcd_(st)
      case (MIX_SET)
         H = this%H_mix_(st)
      case (LAGP_SET)
         H = this%H_lagp_(st)
      case default
         @:ABORT('invalid set')
      end select

      ! Finish

      return

   end function H_

   !****

   function H_dziem_(this, st) result(H)

      class(ad_trans_t), intent(in) :: this
      class(state_rt), intent(in)   :: st
      real(RD)                      :: H(this%n_e,this%n_e)

      ! Evaluate the transformation matrix to convert DZIEM variables
      ! to GYRE's canonical form

      ! Set up the matrix

      H(1,1) = 1._RD
      H(1,2) = 0._RD
      H(1,3) = 0._RD
      H(1,4) = 0._RD

      H(2,1) = 0._RD
      H(2,2) = 1._RD
      H(2,3) = -1._RD
      H(2,4) = 0._RD

      H(3,1) = 0._RD
      H(3,2) = 0._RD
      H(3,3) = 1._RD
      H(3,4) = 0._RD

      H(4,1) = 0._RD
      H(4,2) = 0._RD
      H(4,3) = 0._RD
      H(4,4) = 1._RD

      ! Finish

      return

   end function H_dziem_

   !****

   function H_jcd_(this, st) result(H)

      class(ad_trans_t), intent(in) :: this
      class(state_rt), intent(in)   :: st
      real(RD)                      :: H(this%n_e,this%n_e)

      real(RD) :: omega_c
      real(RD) :: lambda

      ! Evaluate the transformation matrix to convert JCD variables
      ! to GYRE's canonical form

      associate( &
         omega => st%omega, &
         U => this%U, &
         c_1 => this%c_1, &
         Omega_rot => this%Omega_rot, &
         l => this%cx%l, &
         m => this%cx%m, &
         angular_cache => this%cx%angular_cache)

         omega_c = omega - m*Omega_rot

         if (angular_cache) then
            lambda = this%lambda
         else
            lambda = this%cx%lambda(Omega_rot, st)
         end if

         ! Set up the matrix

         if (l /= 0._RD) then

            H(1,1) = 1._RD
            H(1,2) = 0._RD
            H(1,3) = 0._RD
            H(1,4) = 0._RD

            H(2,1) = 0._RD
            H(2,2) = c_1*omega_c**2/lambda
            H(2,3) = 1._RD
            H(2,4) = 0._RD

            H(3,1) = 0._RD
            H(3,2) = 0._RD
            H(3,3) = -1._RD
            H(3,4) = 0._RD

            H(4,1) = 0._RD
            H(4,2) = 0._RD
            H(4,3) = 1._RD - U
            H(4,4) = -1._RD

         else

            H(1,1) = 1._RD
            H(1,2) = 0._RD
            H(1,3) = 0._RD
            H(1,4) = 0._RD

            H(2,1) = 0._RD
            H(2,2) = c_1*omega_c**2
            H(2,3) = 1._RD
            H(2,4) = 0._RD

            H(3,1) = 0._RD
            H(3,2) = 0._RD
            H(3,3) = -1._RD
            H(3,4) = 0._RD

            H(4,1) = 0._RD
            H(4,2) = 0._RD
            H(4,3) = 1._RD - U
            H(4,4) = -1._RD

         endif

      end associate

      ! Finish

      return

   end function H_jcd_

   !****

   function H_mix_(this, st) result(H)

      class(ad_trans_t), intent(in) :: this
      class(state_rt), intent(in)   :: st
      real(RD)                      :: H(this%n_e,this%n_e)

      ! Evaluate the transformation matrix to convert MIX variables
      ! to GYRE's canonical form

      associate( &
         U => this%U)

         ! Set up the matrix

         H(1,1) = 1._RD
         H(1,2) = 0._RD
         H(1,3) = 0._RD
         H(1,4) = 0._RD

         H(2,1) = 0._RD
         H(2,2) = 1._RD
         H(2,3) = 0._RD
         H(2,4) = 0._RD

         H(3,1) = 0._RD
         H(3,2) = 0._RD
         H(3,3) = -1._RD
         H(3,4) = 0._RD

         H(4,1) = 0._RD
         H(4,2) = 0._RD
         H(4,3) = 1._RD - U
         H(4,4) = -1._RD

      end associate

      ! Finish

      return

   end function H_mix_

   !****

   function H_lagp_(this, st) result(H)

      class(ad_trans_t), intent(in) :: this
      class(state_rt), intent(in)   :: st
      real(RD)                      :: H(this%n_e,this%n_e)

      ! Evaluate the transformation matrix to convert LAGP variables
      ! to GYRE's canonical form

      associate( &
         V_2 => this%V_2)

         ! Set up the matrix

         H(1,1) = 1._RD
         H(1,2) = 0._RD
         H(1,3) = 0._RD
         H(1,4) = 0._RD

         H(2,1) = 1._RD
         H(2,2) = 1._RD/V_2
         H(2,3) = 0._RD
         H(2,4) = 0._RD

         H(3,1) = 0._RD
         H(3,2) = 0._RD
         H(3,3) = 1._RD
         H(3,4) = 0._RD

         H(4,1) = 0._RD
         H(4,2) = 0._RD
         H(4,3) = 0._RD
         H(4,4) = 1._RD

      end associate

      ! Finish

      return

   end function H_lagp_

   !****

   function dH_(this, st) result(dH)

      class(ad_trans_t), intent(in) :: this
      class(state_rt), intent(in)   :: st
      real(RD)                      :: dH(4,4)

      ! Evaluate the derivative dH/dx of the transformation matrix H

      select case (this%set)
      case (DZIEM_SET)
         dH = 0._RD
      case (JCD_SET)
         dH = this%dH_jcd_(st)
      case (MIX_SET)
         dH = this%dH_mix_(st)
      case (LAGP_SET)
         dH = this%dH_lagp_(st)
      case default
         @:ABORT('invalid set')
      end select

      ! Finish

      return

   end function dH_

   !****

   function dH_jcd_(this, st) result(dH)

      class(ad_trans_t), intent(in) :: this
      class(state_rt), intent(in)   :: st
      real(RD)                      :: dH(this%n_e,this%n_e)

      real(RD) :: omega_c
      real(RD) :: lambda
      real(RD) :: invx

      ! Evaluate the derivative dH/dx of the JCD-variables
      ! transformation matrix H

      associate( &
         omega => st%omega, &
         U => this%U, &
         dU => this%dU, &
         c_1 => this%c_1, &
         dc_1 => this%dc_1, &
         Omega_rot => this%Omega_rot, &
         x => this%x, &
         l => this%cx%l, &
         m => this%cx%m, &
         angular_cache => this%cx%angular_cache)

         omega_c = omega - m*Omega_rot

         if (angular_cache) then
            lambda = this%lambda
         else
            lambda = this%cx%lambda(Omega_rot, st)
         end if

         ! Set up the matrix (nb: the derivatives of omega_c and lambda are
         ! neglected; this is incorrect when rotation is non-zero)

         invx = 1._RD/x

         if (l /= 0._RD) then

            dH(1,1) = invx*0._RD
            dH(1,2) = invx*0._RD
            dH(1,3) = invx*0._RD
            dH(1,4) = invx*0._RD

            dH(2,1) = invx*0._RD
            dH(2,2) = invx*c_1*dc_1*omega_c**2/lambda
            dH(2,3) = invx*0._RD
            dH(2,4) = invx*0._RD

            dH(3,1) = invx*0._RD
            dH(3,2) = invx*0._RD
            dH(3,3) = invx*0._RD
            dH(3,4) = invx*0._RD

            dH(4,1) = invx*0._RD
            dH(4,2) = invx*0._RD
            dH(4,3) = invx*(-U*dU)
            dH(4,4) = invx*0._RD

         else

            dH(1,1) = invx*0._RD
            dH(1,2) = invx*0._RD
            dH(1,3) = invx*0._RD
            dH(1,4) = invx*0._RD

            dH(2,1) = invx*0._RD
            dH(2,2) = invx*c_1*dc_1*omega_c**2
            dH(2,3) = invx*0._RD
            dH(2,4) = invx*0._RD

            dH(3,1) = invx*0._RD
            dH(3,2) = invx*0._RD
            dH(3,3) = invx*0._RD
            dH(3,4) = invx*0._RD

            dH(4,1) = invx*0._RD
            dH(4,2) = invx*0._RD
            dH(4,3) = invx*(-U*dU)
            dH(4,4) = invx*0._RD

         endif

      end associate

      ! Finish

      return

   end function dH_jcd_

   !****

   function dH_mix_(this, st) result(dH)

      class(ad_trans_t), intent(in) :: this
      class(state_rt), intent(in)   :: st
      real(RD)                      :: dH(this%n_e,this%n_e)

      real(RD) :: invx

      ! Evaluate the derivative dH/dx of the MIX-variables
      ! transformation matrix H

      ! Calculate coefficients

      associate( &
         U => this%U, &
         dU => this%dU, &
         x => this%x)

         ! Set up the matrix

         invx = 1._RD/x

         dH(1,1) = invx*0._RD
         dH(1,2) = invx*0._RD
         dH(1,3) = invx*0._RD
         dH(1,4) = invx*0._RD

         dH(2,1) = invx*0._RD
         dH(2,2) = invx*0._RD
         dH(2,3) = invx*0._RD
         dH(2,4) = invx*0._RD

         dH(3,1) = invx*0._RD
         dH(3,2) = invx*0._RD
         dH(3,3) = invx*0._RD
         dH(3,4) = invx*0._RD

         dH(4,1) = invx*0._RD
         dH(4,2) = invx*0._RD
         dH(4,3) = invx*(-U*dU)
         dH(4,4) = invx*0._RD

      end associate

      ! Finish

      return

   end function dH_mix_

   !****

   function dH_lagp_(this, st) result(dH)

      class(ad_trans_t), intent(in) :: this
      class(state_rt), intent(in)   :: st
      real(RD)                      :: dH(this%n_e,this%n_e)

      real(RD) :: invx

      ! Evaluate the derivative dH/dx of the LAGP-variables
      ! transformation matrix H

      associate( &
         V_2 => this%V_2, &
         dV_2 => this%dV_2, &
         x => this%x)

         ! Set up the matrix

         invx = 1._RD/x

         dH(1,1) = invx*0._RD
         dH(1,2) = invx*0._RD
         dH(1,3) = invx*0._RD
         dH(1,4) = invx*0._RD

         dH(2,1) = invx*0._RD
         dH(2,2) = invx*(-dV_2/V_2)
         dH(2,3) = invx*0._RD
         dH(2,4) = invx*0._RD

         dH(3,1) = invx*0._RD
         dH(3,2) = invx*0._RD
         dH(3,3) = invx*0._RD
         dH(3,4) = invx*0._RD

         dH(4,1) = invx*0._RD
         dH(4,2) = invx*0._RD
         dH(4,3) = invx*0._RD
         dH(4,4) = invx*0._RD

      end associate

      ! Finish

      return

   end function dH_lagp_

end module ad_trans_m
